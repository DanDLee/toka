|
| Toka in RetroForth
|
| This is a long-term project, to aid in implementing
| Toka on PalmOS based devices (via Quartus) and perhaps
| other systems without GCC.
|
| Once loaded, the underlying Forth language will be suppressed,
| leaving only Toka visible.
|
| Todo:
|  - Nestable quotes
|    - Conditionals
|    - Loop operators
|  - Finish core primitives
|  - Garbage Collector (fill in empty stubs)
|  - Actual support for 'parser' state variable
|  - Command line arguments (as a Toka style array)
| ------------------------------------------------------------

1 import strlen
2 import strcpy
1 import malloc
1 import free

|
| Comments
|
: #! lnparse 2drop ;
self: ( ') parse 2drop ;

|
| Cell and Character Sizing
| This is easy, since RetroForth is tied to 32-bit
| x86 architecture :)
|
4 constant cell-size
1 constant char-size


|
| Quotes
|
128 cells constant QUOTE-SIZE
self: [ here QUOTE-SIZE malloc dup h0 ! state on ;
self: ] state off $c3 1, swap h0 ! ;

|
| Naming of quotes and data
|
: is alias ;
: is-macro self alias forth ;
: is-data create last @ :xt ! ;


|
| Map in (and rename where necessary) 
| Forth words. These are words that work
| the same in Forth and Toka.
| 
[ execute ] is invoke
[ + ] is +
[ - ] is -
[ * ] is *
[ /mod ] is /mod
[ @ ] is @
[ ! ] is !
[ c@ ] is c@
[ c! ] is c!
[ << ] is <<
[ >> ] is >>
[ and ] is and
[ or ] is or
[ xor ] is xor
[ emit ] is emit
[ . ] is .
[ <> ] is <>
[ = ] is =
[ < ] is <
[ > ] is >
[ swap ] is swap
[ drop ] is drop
[ dup ] is dup
[ words ] is :names
[ .s ] is :stack
[ bye ] is bye
[ include ] is include
[ ' ] is-macro `
[ literal, ] is #
[ compile ] is compile
` state is-data compiler
` base is-data base
` last is-data last

macro
` >r alias >r
` r> alias r>
forth


|
| Allow use of FFI (retro and toka share the same FFI model)
|
[ from ] is from
[ import ] is import


|
| Useful constants
|
[ -1 ] is TRUE
[  0 ] is FALSE


|
| Some things (such as 'parse', '>number', 'type', etc
| need to return/use zero terminated strings for Toka
| to operate properly. This wraps the Forth versions with
| the necessary code to emulate Toka behaviour.
|
[ parse        ( char -- addr len )
  dup >r       ( addr len -- addr len | rs: len )
  over +       ( addr len -- addr addr+len | rs: len )
  0 swap c!    ( addr addr+len -- addr | rs: len )
  r> 1+ malloc ( addr -- addr new-addr )
  dup >r swap  ( addr new-addr -- new-addr addr | rs: new-addr )
  strcpy       ( new-addr addr -- count )
  drop r>      ( count -- new-addr )
] is parse
[ dup strlen 1+ ] is count
[ count 1- type ] is type
[ count 1- >number ] is >number
[ 34 parse state @ if literal, then ] is-macro "


|
| Stubs and Incomplete
|
[ ] is gc
[ ] is :gc
[ ] is keep
variable parser  parser on


` malloc >entry :link 0 swap !

" Toka (for RetroForth)" type 10 emit
