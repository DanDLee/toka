#! /usr/bin/toka
#! ---------------------------------------------------------------
#! HTTP Based Listener
#!
#! This is an attempt to develop a browser-based interface to
#! Toka. Eventually it should support the following features:
#!
#!  - Browse Definitions
#!    - Choose from a list
#!    - See code or current value
#!  - Browse Documentation
#!    - Generated by TokaDoc
#!    - Show for specific word being examined
#!  - Write Code
#!    - One line "query" type
#!    - Larger editing box if needed
#!    - Display output in a separate pane
#!  - Debugging
#!    - Get at current system state
#!      - This may need more low-level primitives (: words?)
#!    - Run code in a separate process
#!
#! This code is based on the HTTP/0.9 Compliant Server developed
#! by erider and Charles Childers. It may be used under the terms 
#! of the MIT/X11 License.
#! ---------------------------------------------------------------

{

#! =============================================================== LIBRARIES NEEDED
needs strings
needs sockets
needs shell
needs case

from libc.so.6
3 import memset     #! void *memset(void *s, int c, size_t n);
6 import sprintf 
#! ---------------------------------------------------------------



#! =============================================================== CONFIGURARTION
 " /var/www/htdocs/" is-data DEFAULT-DOCROOT
 " home.html" is-data DEFAULT-PAGE

#! ---------------------------------------------------------------
#! HTML Document Root 
#!
#! The HTTP server allows overriding the default docroot at the
#! command line. For example:
#!
#! ./httpd.toka /var/www/
#! ---------------------------------------------------------------

#args 1 = [ 1 arglist array.get ]
          [ DEFAULT-DOCROOT ] ifTrueFalse
is-data docroot
#! ---------------------------------------------------------------

#! ---------------------------------------------------------------
#! UNKNOWN
#! Sent when help for a word is not found.
#! ---------------------------------------------------------------
[ " <p>Sorry, but the word you requested has no help.</p>" ] is UNKNOWN


#! =============================================================== SOCKET I/O
#! Several buffers used for input and CGI related tasks
#! ---------------------------------------------------------------
1024 chars is-data 1KiB
1KiB is-array buffer
1KiB is-array scratch


#! ---------------------------------------------------------------
#! Extend reset to purge the input buffer as well as the stack
#! ---------------------------------------------------------------
[ buffer 0 1KiB memset reset ] is reset


#! ---------------------------------------------------------------
#! new-connection
#! Setup a new connection. This involves bindings port 80 to 
#! localhost, and waiting for a client to connect to it. The 
#! connection and socket variables are set by this code.
#!
#! end-connection
#! Closes the current connection. This allows for new connections
#! to be made.
#! ---------------------------------------------------------------
variable| socket connection |

9812 pBind socket !
[ socket @ pAccept connection ! ] is new-connection
[ connection @ pClose ] is end-connection


#! ---------------------------------------------------------------
#! send
#! Send a string to the currently connected client
#! ---------------------------------------------------------------
[ >r connection @ r> count char- pWrite drop ] is send


#! ---------------------------------------------------------------
#! get-request
#! This reads a client request of up to 1k into the buffer. The
#! number of bytes read is returned.
#! ---------------------------------------------------------------
[ connection @ buffer 1KiB pRead ] is get-request




#! =============================================================== REQUEST HANDLING, PART 1

#! ---------------------------------------------------------------
#! The following section is for processing requests
#! Method:    Function:
#! --------------------------------------------------------------- 
#! GET     -  the word GET, used for locating a GET request
#! DELIMS  -  A set of delimiters used to help break apart 
#!            the request
#! REQUEST -  A string containing a three character request. This
#!            may need to be made larger in the future.
#! ---------------------------------------------------------------
 " GET"  is-data GET
 " \n "  is-data DELIMS

 4 chars is-array REQUEST 
 0 3 REQUEST array.putChar   ( Add a null byte to the REQUEST array )


#! ---------------------------------------------------------------
#! split-request
#! Copy the first three characters from buffer to REQUEST
#!
#! Three characters is enough to identify the most important 
#! requests.
#! ---------------------------------------------------------------
[ buffer REQUEST 3 copy REQUEST ] is split-request


#! ---------------------------------------------------------------
#! extract-filename
#! Strip out the leading / and junk that follows the requested
#! filename.
#! ---------------------------------------------------------------
[
  buffer " /" string.findSubstring char+ 
  DELIMS string.findToken
] is extract-filename


#! ---------------------------------------------------------------
#! obtain-filename
#! Return a filename from the request. This checks for requests
#! like "GET /" as well as requests like "GET /filename".
#! ---------------------------------------------------------------
[
  buffer " /" string.findSubstring 
  DELIMS string.findToken " /" strcmp 0 =
  [ DEFAULT-PAGE ]
  [ extract-filename ]
  ifTrueFalse
] is obtain-filename




#! =============================================================== FILE TYPES
#! check-type
#! Check to see if the requested filename matches the pattern. If
#! so, invokes the quote.
#! ---------------------------------------------------------------
[ swap >r obtain-filename basename 0 fnmatch 0 = r> ifTrue ] is check-type


#! ---------------------------------------------------------------
#! text-file
#! Default handler for any type of text file. This is factored
#! out from return-requested.
#! ---------------------------------------------------------------
[ docroot obtain-filename string.append ] is text-file




#! =============================================================== REQUEST HANDLING, PART 2

#! =============================================================== LOGGING
#! Log requests to stdout.
#! This takes a standard form of:
#!   REQUEST #  client-request
#! Most should be GET requests.
#! ---------------------------------------------------------------
#! #requests - The total number of requests since the 
#!             server started 
#!
#! log-request
#! Increment #requests and display the request number and actual
#! GET request.
#! ---------------------------------------------------------------
variable| #requests |
[
  1 #requests +!
  ." REQUEST #" #requests @ . space space
  buffer " \n" string.findToken type cr
] is log-request


[ " <html>\n<head>\n<title>Toka: Listener</title>\n" send
  " <style>\n" send
    " .name { background: #cccccc; width: 600px%; font-size: 18pt; font-family: sans-serif; font-style: normal; font-weight: bold; }" send
    " .stack { font-weight: bold; }" send
    " .description { }" send
  " </style>" send
  " </head>\n<body>\n" send 
] is html-begin
[ " </body></html>" send ] is html-end

[ ( - )   " <form id=\"main\" action=\"browse\" method=\"get\">\n" send ] is form-begin
[ ( - )   " </form>\n" send ] is form-end


2 chars is-array output
value source
[ ( $- )
  dup to source
  count char- nip
  [
    i char- source array.getChar   
    switch
      char: < [ " &lt;" send break ] case
      char: > [ " &gt;" send break ] case
      char: & [ " &amp;" send break ] case
      [ <cond> 0 output array.putChar output send ] default 
  ] +iterate
] is send-with-escapes
[ ( $- )  " <option>" send send-with-escapes " </option>" send ] is <option>


[ ( - )
  " <select name=\"word\" style=\"width: 200px;\" size=\"20\" onchange=\"javascript:document.getElementById('main').submit();\">\n" send
  last @ [ i :name <option> ] iterate
  " </select>\n" send
] is select-word

include helpdb
[ extract-filename count 13 chars > [ 12 chars + ] ifTrue :help ] is display-help

[ html-begin
  form-begin
  " <table width='800px'>\n<tr><td width='200px'>" send
  select-word
  " </td><td valign=top width='600px'>" send 
  display-help " </td>" send
  " </tr></table>" send
  form-end
  html-end
] is send-table


#! =============================================================== MAIN LOOP
." ---------- Starting Toka HTTP Listener ----------\n"

[
  new-connection
  get-request 
  log-request
  send-table
  end-connection
  reset
  TRUE
] keep
}
 whileTrue
bye
