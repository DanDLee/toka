# Notebook Database File

#--------------------------------------------------
# bits.c

page bits.c {= Use =

This file provides a handful of primitives for manipulating bits.

= Functions Provided =

#pre
lshift()
Shift TOS left by NOS bits

rshift()
Shift TOS right by NOS bits

and()
Perform a bitwise AND

or()
Perform a bitwise OR

xor()
Perform a bitwise XOR
#unpre

= Primitives Provided =

#pre
<<       ( ab-c )    Shift 'b' left by 'a' bits
>>       ( ab-c )    Shift 'b' right by 'a' bits
and      ( ab-c )    Perform a bitwise AND
or       ( ab-c )    Perform a bitwise OR
xor      ( ab-c )    Perform a bitwise XOR
#unpre} 1175295170


#--------------------------------------------------
# Building

page Building {To build Toka, you will need the following:

* GCC 2.9x, 3.x, or 4.x
* Make (GNU Make is recommended, though others may work)

For most people, the following should work. If it fails, try checking the
[Ports] page to see if there are any platform-specific instructions. The
process using Make:

#pre
  make
#unpre

The build system should be able to detect the need for libdl.so (Linux,
BeOS) or whether dlopen() and dlsym() are provided by libc.so (BSD). You
can also build a version without the [FFI], but this is not recommended
as it reduces the usefulness of Toka significantly. This can be done via:

#pre
  make vanilla
#unpre

If you are using the experimental Cygwin support, build using:

#pre
  make cygwin
#unpre

As a final note, some pieces of documentation can be updated automatically
as well:

#pre
  make docs
#unpre} 1176347063


#--------------------------------------------------
# class.c

page class.c {= Use =

This is where the [word classes] are implemented. It does not export any
functions directly to Toka.

= Functions Provided =

#pre
forth_class()
If compiling, compile the xt into the current
quote. If interpreting, call the word.

self_class()
Always call the word

data_class()
If compiling, compile a call to lit() and then
inline TOS into the following location. Otherwise
leave TOS alone.

quote_super_class()
Always invoke the quote.

quote_class()
Handler for quotes; this takes two cells, one
which is a call to this function, the other is
the pointer to the quote to invoke.

quote_macro_class()
If compiling, invoke the quote. If interpreting,
silently ignore it.

quote_forth_class()
Perform data_class() semantics, then, if 
compiling, compile a call to invoke(). Otherwise,
invoke() is called with the xt on TOS.
#unpre

= Primitives Provided =

<i>None</i>} 1175293842


#--------------------------------------------------
# cmdline.c

page cmdline.c {= Use =

Build the list of command line arguments that Toka programs can access.
This is a subset of the full arguments passed to the <b>toka</b> executable.

= Functions Provided =

#pre
Variables:
  long arg_count
  Holds the number of command line arguments

  char *arg_list[12]
  Holds the list of command line arguments. 

num_args()
Return the number of arguments, not including the
file names used to launch this program.

get_arg_list()
Return the number of arguments, not including the
file names used to launch this program.

build_arg_list(char *args[], long count)
Copy pointers to the command line arguments to
arg_list[]. Also sets arg_count.
#unpre

= Primitives Provided =

#pre
#args
arglist
#unpre} 1175293792


#--------------------------------------------------
# Conditionals

page Conditionals {Toka provides a few basic comparison primitives and one primitive for
handling conditional execution of code. The standard bootstrap also adds
two quotes that extend the conditional functions.

Basic examples:

#pre
  1 100 = [ 1 . ] true?
  1 100 = [ 2 . ] false?
  1 100 = [ 3 . ] [ 4 . ] t/f
#unpre

The first case will invoke the quote if the flag returned by <b>=</b> is
TRUE. The second invokes the quote if the flag is FALSE, and the third
form invokes the <b>[ 3 . ]</b> quote if TRUE, or the <b>[ 4 . ]</b>
quote if FALSE.} 1177019564


#--------------------------------------------------
# conditionals.c

page conditionals.c {= Use =

Contains the implementation of the core conditionals. These are words
which do comparisons, and return a flag on the stack.

= Functions Provided =

#pre
less_than()
Compare TOS and NOS, return a flag.

greater_than()
Compare TOS and NOS, return a flag.

equals()
Compare TOS and NOS, return a flag.

not_equals()
Compare TOS and NOS, return a flag.
#unpre

= Primitives Provided =

#pre
<
>
=
<>
#unpre} 1175293903


#--------------------------------------------------
# console.c

page console.c {= Use =

Provide a very basic console interface. The provided interface is
intentionally kept to a minimum, a better console interface can be loaded later.

= Functions Provided =

#pre
dot()
Display the number on TOS using the current base
if possible.

emit()
Display the character TOS corresponds to. Consumes
TOS.

type()
Display the string TOS points to. Consumes TOS.

bye()
Quit Toka
#unpre

= Primitives Provided =

#pre
.
emit
type
bye
#unpre} 1175293981


#--------------------------------------------------
# data.c

page data.c {= Use =

These are words useful for accessing and modifying data.

= Functions Provided =

#pre
make_literal()
Compile a call to lit() and then place TOS into
the next memory location.

fetch()
Fetch the value in the memory location pointed to
by TOS.

store()
Store NOS into the memory location specified by
TOS.

fetch_char()
Fetch the value in the memory location pointed to
by TOS. This version reads a single byte.

store_char()
Store NOS into the memory location specified by
TOS. This version stores a single byte.

copy()
Copies 'count' bytes from 'source' to 'dest'. The
stack form for this is:
  source dest count
The memory locations can overlap.

cell_size()
Push the size of a cell to the stack.

char_size()
Push the size of a char to the stack
#unpre

= Primitives Provided =

#pre
char-size
cell-size
copy
c!
c@
!
@
#
#unpre} 1175294055


#--------------------------------------------------
# debug.c

page debug.c {= Use =

This provides a very small collection of simple tools that can be helpful
when trying to track down bugs. It is not intended to be a full-scale
debugging tool.

= Functions Provided =

#pre
words()
Display a list of all named words

display_stack()
Display all items on the stack.

gc_info()
Display information about Toka's memory use
#unpre

= Primitives Provided =

#pre
:words
:stack
:gc
#unpre} 1176258298


#--------------------------------------------------
# decompile.c

page decompile.c {= Use =

This allows for decompiling a quote and displaying the source needed to
recreate it. 

= Functions Provided =

#pre
long resolve_name(Inst xt)
Search for a name in the dictionary that corresponds
to 'xt'. Display it if found, and return a flag.

decompile(Inst *xt)
Decompile a quote and its children and display the
result on the screen.

see()
Decompile the quote on the stack.
#unpre

= Primitives Provided =

#pre
:see
#unpre} 1175294160


#--------------------------------------------------
# dictionary.c

page dictionary.c =\ Use\ =\n\nThis\ file\ provides\ the\ functionality\ to\ create\ new\ dictionary\ entries\ and\nsearch\ for\ a\ specific\ entry.\n\n=\ Functions\ Provided\ =\n\n#pre\nVariables:\n\ \ ENTRY\ dictionary\[4096\]\;\n\ \ Holds\ the\ dictionary\ entries,\ up\ to\ 4096\n\n\ \ long\ last\n\ \ A\ pointer\ to\ the\ most\ recent\ dictionary\ entry\n\nadd_entry(char\ *name,\ Inst\ xt,\ Inst\ class)\nAdd\ an\ entry\ to\ the\ dictionary.\n\nname_attach(void\ *class)\nAttach\ a\ name\ (from\ the\ input\ stream)\ to\ the\ \nspecified\ quote\ address.\ This\ word\ is\ given\ the\nsemantics\ of\ the\ specified\ class.\n\nname_quote()\nAttach\ a\ name\ (from\ the\ input\ stream)\ to\ the\ \nspecified\ quote\ address.\ This\ word\ is\ given\ the\nsemantics\ of\ quote_forth_class().\n\nname_super()\nAttach\ a\ name\ (from\ the\ input\ stream)\ to\ the\ \nspecified\ quote\ address.\ This\ word\ is\ given\ the\nsemantics\ of\ quote_super_class().\n\nname_quote_macro()\nAttach\ a\ name\ (from\ the\ input\ stream)\ to\ the\ \nspecified\ quote\ address.\ This\ word\ is\ given\ the\nsemantics\ of\ quote_macro_class().\n\nname_data()\nAttach\ a\ name\ (from\ the\ input\ stream)\ to\ the\ data\nat\ the\ specified\ address.\ Semantics\ are\ the\ same\nas\ the\ data_class().\n\nfind_word()\nSearch\ for\ a\ word\ (name\ taken\ from\ the\ string\npassed\ on\ TOS)\ in\ the\ dictionary.\ Returns\ the\nxt,\ class,\ and\ a\ flag\ of\ -1\ if\ found.\ If\ not\nfound,\ returns\ only\ a\ flag\ of\ 0.\n\nreturn_quote()\nFind\ a\ name\ (from\ the\ input\ stream)\ and\ return\ a\nquote\ that\ corresponds\ to\ the\ word.\n#unpre\n\n=\ Primitives\ Provided\ =\n\n#pre\nis\nis-data\nis-macro\nis-super\n\\\nlast\n#unpre 1175294300


#--------------------------------------------------
# errors.c

page errors.c {= Use =

This is where errors are handled. It does not export any functions
directly to Toka.

= Functions Provided =

#pre
error(long code)
Display a given error by code
#unpre

= Primitives Provided =

<i>None</i>
} 1177177214


#--------------------------------------------------
# FFI

page FFI {To allow use of external libraries, Toka provides a simple <i>Foreign
Function Interface</i> (FFI). This is built around the following
primitives:

#pre
  from LIBRARY
#unpre

Set the import source to LIBRARY. This should be a fully-qualified
filename; it may require a path as well as the .so extension.

#pre
  N import FUNCTION
#unpre

Import FUNCTION from the previously specified library. A new quote named
FUNCTION will be created, and will take N arguments off the stack. This
function will always have a return value, even for <i>void</i> functions.

You can also make use of <b>as</b> to rename the imported function.

#---
Example:

#pre
  #! Linux libc = libc.so.6, BSD libc = libc.so
  from libc.so.6
  2 import printf as printf.2
  " %i\n" 100 printf.2
#unpre

#---
The FFI is optional, and can be disabled at build time. Doing so reduces
the overall functionality of Toka, so doing this is only recommended if
you are using a system without dlopen()/dlsym(), or if you need more 
direct control over the functionality provided.} 1176258153


#--------------------------------------------------
# ffi.c

page ffi.c {= Use =

Implements the [Foreign Function Interface|FFI], which allows use of external
libraries.

= Functions Provided =

#pre
Variables:
  void *library
  Pointer to the most recently opened library

ffi_invoke()
Call a foreign function. This translates between
Toka and CDECL calling conventions.

ffi_from()
Select a library to load from.

ffi_import()
Import and name an external function. This wraps
the imported function in a quote.

ffi_rename()
Rename the most recently defined word in the
dictionary.
#unpre

= Primitives Provided =

#pre
from
import
as
#unpre} 1176257909


#--------------------------------------------------
# files.c

page files.c {= Use =

Allows for reading and writing data to files.

= Functions Provided =

#pre
file_open()
Open a file using the specified mode. Modes are
a direct map to the fopen() modes: "r", "r+", "w",
"w+", "a", and "a+". Numeric values for these are
1 - 6, in that order.

file_close()
This is just a simple wrapper over fclose().

file_read()
This is just a simple wrapper over fread().

file_write()
This is just a simple wrapper over fwrite().

file_size()
This is just a simple wrapper over fstat() which
returns the size of the file.

file_seek()
This is just a simple wrapper over fseek().

file_pos()
This is just a simple wrapper over ftell().
#unpre

= Primitives Provided =

#pre
file.open
file.close
file.read
file.write
file.size
file.seek
file.pos
#unpre} 1175294463


#--------------------------------------------------
# First Steps

page {First Steps} {At present, Toka provides a basic <i>listener</i> as the only interface.
This is a console-based enviroment where you can type commands and get
instant feedback. Let's get started:

#pre
  crc@strider: toka
#unpre

If you built and installed Toka properly, it should start, displaying a
message like:

#pre
  toka (svn build)
#unpre

At this point, you can begin entering code. Let's start by exploring the
enviroment a little:

#pre
  :names
#unpre

Invoking <b>:names</b> will display all named elements in the currently
running Toka. Don't panic at the number of items -- you only need to
learn a handful of them to write code in Toka.  The list is divided into
three groups:

* Primitives, the building blocks everything else is based on
* Quotes, everything in the <i>bootstrap.toka</i> and anything you write
* Data, for variables, arrays, and other data structures

Now let's delve into actually using Toka a bit.

=== Introductory Bits ===
* [The Stack|UsingTheStack]
* [Basic Math|MathOperations]

=== Intermediate Exploration ===
* [Quotes]
* [Loops]
* [Conditionals]
* [Variables]} 1177020293


#--------------------------------------------------
# garbage collector

page {garbage collector} {The Toka implementation makes heavy use of dynamically allocated memory.
To help avoid memory leaks, the memory allocation provides a very simple
form of <i>garbage collection</i>.

The model is very simple. A list containing pointers to each allocation,
and the corresponding size (in bytes) is kept. Each time memory is
requested, the code adds the request to the list. When the list is filled,
or if the allocation fails, the 16 oldest items are freed and all later
entries are shifted down.

Obviously there is also a way to mark entries as permanent. This is done
by <b>keep</b> (the <b>[gc_keep()|gc.c]</b> function). This routine skims
through the list of allocations (from most recent to oldest) looking for
a specific pointer. When found, that entry (and any subsequent
allocations -- in Toka these will almost always be subquotes, strings,
etc) are removed from the list.

In actual practice things are just a little more complex. Toka actually
maintains two lists; one for general allocations and a second one for
internal use. The second one is only used for allocations that are known
to be temporary. 

In addition, the code will always leave the 16 newest allocations in each
list alone to prevent them from falling out of scope.
 
Information regarding the current status of the garbage collection
subsystem can be obtained via <b>:gc</b> (the <b>[gc_info()|debug.c]</b> function).} 1176697195


#--------------------------------------------------
# gc.c

page gc.c {= Use =

Implements the memory allocator and basic [garbage collector].

= Functions Provided =

#pre
Variables:
  GCITEM gc_list[128]
  Holds the list of items marked as garbage

  long gc_depth
  A pointer to the top of the garbage collection
  list

  GCITEM gc_trash[128]
  Holds the short list of items marked as garbage

  long gc_tdepth
  A pointer to the top of the short garbage
  collection list

  long gc_used
  Contains the total size of all currently used
  memory, including permanent quotes.

  long gc_objects
  Contains the total number of objects that are
  currently existing, including permanent ones.

gc_alloc(long items, long size, long type)
Allocate the requested memory and add it to the
garbage collection list.
If type is set to 0, add to the normal garbage
collection list. If set to 1, add to the short
list of known garbage items which can be safely
freed at the next gc().
If the allocation fails, gc() is called, and the
allocation is retried. If it still fails, an
error is reported and Toka is terminated.

gc_keep()
Remove the specified address (and any childern it
has registered) from the garbage collection list.
If the TOS is not an allocated address, this will
silently ignore it.

gc()
Free the oldest allocations on the garbage list.
Will free up to 16 items from each list per
call. If there are 16 or less items remaining,
this code will leave the allocations alone.

toka_malloc()
Allocate TOS bytes of memory. Returns a pointer to
the allocated memory.
#unpre

= Primitives Provided =

#pre
keep
gc
malloc
#unpre} 1177018702


#--------------------------------------------------
# Home

page Home {Hello, and welcome to Toka!

Toka is a small programming language. It is considered experimental, and 
may change without warning.

The language has been influenced by my experiences with RetroForth, 
HelFORTH, Factor, and other languages. I find it fun and rewarding to 
work on, even if it's not as practical as other languages.

= General Topics =

* [License]
* [Building] and [Installation]
* [First Steps]
* [Words and Their Uses]
* [Ports]

= Internals =

=== Topics ===

* [FFI]
* [Loops]
* [Conditionals]
* [garbage collector]
* [threading model]
* [TokaDoc]

=== Source Files ===

* [bits.c]
* [class.c]
* [cmdline.c]
* [conditionals.c]
* [console.c]
* [data.c]
* [debug.c]
* [decompile.c]
* [dictionary.c]
* [errors.c]
* [ffi.c]
* [files.c]
* [gc.c]
* [initial.c]
* [interpret.c]
* [math.c]
* [parser.c]
* [quotes.c]
* [stack.c]
* [toka.c]
* [vm.c]
} 1177177126


#--------------------------------------------------
# Index

page Index {[@pageIndex@]} 1026586734


#--------------------------------------------------
# initial.c

page initial.c {= Use =

Build the initial dictionary

= Functions Provided =

#pre
build_dictionary()
Attach names and classes to the various initial
words in the Toka language.
#unpre

= Primitives Provided =

<i>None</i>} 1175294584


#--------------------------------------------------
# Installation

page Installation {To get the most out of Toka, it needs to be installed. This can be done
via the build system:

#pre
  make install
#unpre

When done this way, the following files are installed:

/usr/bin/toka
/usr/share/toka/bootstrap.toka

After installation, run the test suite:

#pre
  make tests
#unpre

Look for any failures in the test.log. If you encounter a problem, please
forward the test.log to charles.childers@gmail.com along with some
basic information about your system (OS, CPU type, GCC version, Toka
revision #)} 1175313503


#--------------------------------------------------
# interpret.c

page interpret.c {= Use =

The interpreter itself.

= Functions Provided =

#pre
Variables:
  long compiler
  When set to 0, interpret; when set to -1, 
  compile. This is checked by the various word
  classes defined in class.c

  char *scratch
  Temporary holding area used by the parser and
  other routines.

  char *tib
  Pointer to the text input buffer.

count()
Perform strlen() on the string passed on TOS. This
returns the string and the count on the stack. The
count is increased by 1 to include the trailing 
ASCII 0.

interpret()
Accept and process input.
#unpre

= Primitives Provided =

#pre
compiler
count
#unpre
} 1177177233


#--------------------------------------------------
# License

page License {Toka is Copyright (c) 2007 Charles R. Childers


Permission is hereby granted, free of charge, to any person obtaining a copy 
of this software and associated documentation files (the "Software"), to deal 
in the Software without restriction, including without limitation the rights 
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell 
copies of the Software, and to permit persons to whom the Software is furnished 
to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in 
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
IN THE SOFTWARE.} 1175645279


#--------------------------------------------------
# Loops

page Loops {Toka provides a limited collection of primitives for building various
types of simple loops.

The most basic form is <b>iterate</b>, which takes the following form:

#pre
  number-of-iterations quote  iterate
#unpre

<b>iterate</b> will invoke <i>quote</i> the specified number of times.
With <b>iterate</b>, the count goes down from N to 1, with 1 being the
last cycle of the loop. To count up from 1 to N instead, use
<b>+iterate</b>. Other than this, both of these words take the same form.
Some examples:

#pre
  10 [ i . ] iterate
  10 [ i . ] +iterate
#unpre

Note the use of <b>i</b>, the loop index. When looping via <b>iterate</b>
and <b>+iterate</b>, the loop index is set to the current cycle number.
<i>Other types of loops do not set the loop index.</i> 

The other type of loop is a <b>whileTrue</b> or <b>whileFalse</b> loop.
The normal form:

#pre
  quote whileTrue
  quote whileFalse
#unpre

Each time <i>quote</i> is invoked, a value of <b>TRUE</b> or <b>FALSE</b>
should be left on the stack. The loop primitives will consume this, and
either repeat the loop or end the loop until the condition is not met.
<b>whileTrue</b> continues execution if the returned value is <b>TRUE</b>;
<b>whileFalse</b> continues if the returned value is <b>FALSE</b>.

Some examples:

#pre
  1 [ dup . 1 + dup 101 < ] whileTrue
  101 [ dup . 1 - dup 1 < ] whileFalse
#unpre} 1177019422


#--------------------------------------------------
# math.c

page math.c {= Use =

Basic math operations on the stack.

= Functions Provided =

#pre
add()
Add TOS to NOS

subtract()
Subtract TOS from NOS

multiply()
Multiply TOS by NOS

divmod()
Divide and return the result, including remainder
#unpre

= Primitives Provided =

#pre
+
-
*
/mod
#unpre} 1175294665


#--------------------------------------------------
# MathOperations

page MathOperations {Toka provides a very basic set of math functionality, sufficient for many
purposes. The functions are:

#pre
  +        ( ab-c )    Add TOS and NOS
  -        ( ab-c )    Subtract TOS from NOS
  *        ( ab-c )    Multiply TOS by NOS
  /mod     ( ab-cd )   Divide and get remainder
#unpre

In addition, the standard bootstrap adds some additional operations:

#pre
  1+       ( x-y )     Increase value on stack by 1
  1-       ( x-y )     Decrease value on stack by 1
  negate   ( x-y )     Invert the sign of TOS
  /        ( xy-z )    Divide two numbers
  mod      ( xy-z )    Divide two numbers and get remainder
  not      ( x-y )     Invert the value 'x'
  */       ( abc-d )   (a*b)/c
#unpre} 1177020107


#--------------------------------------------------
# New Pages

page {New Pages} {To create a new page,

* Add a link to it in this page (or on any other page where the link would
  be more appropriate):
** Press the "Edit" button.
** Go to the bottom of the page (or anywhere, really).
** Type the page's name in square brackets, &lb;Like This&rb;.
** Press the "Done" button.
* Click on the link.
* On the Status Line, down at the bottom of the window, Notebook will ask
  if you want to create the page.  Type "yes" or "y", and press Enter.

<h>New Pages</h>

* [Tour]
* [Sandbox]} 1102291321


#--------------------------------------------------
# parser.c

page parser.c {= Use =

Implement the parser.

= Functions Provided =

#pre
Variables:
  FILE *input[]
  Current file stream to parse from. Setup as
  an array of 8 inputs.

  long isp
  Pointer to the most recent input source in the array

  long base
  Holds the current numeric base

  long parser
  When ON (TRUE), system parsing words will parse. When
  OFF (FALSE), they will take a string from the stack.

to_number()
Attempt to convert a string (on TOS) to a number.
This accepts a format of:
  [-]number
If successful, it leaves the number and a flag of
-1 on the stack. Otherwise, it leaves the original
string, and a flag of 0.

parse()
Parse the input buffer until the character passed
on TOS is found, or until the end of the line is
encountered. Return a pointer to the resulting
string on the stack.

get_token(char *s, long delim)
Return a string (in "s") up to the specified 
delimiter. This also puts the resulting string 
on the stack.

long include_file(char *s)
Attempt to open a file ("s") and add it to the
top of the input stack.

include()
Take a filename off the stack, attempt to open
it and add it to the input stream if successful.

needs()
Take a filename off the stack. Attempt to open it
from the library, and add it to the input stream 
if successful.

force_eof()
Remove the current file from the input stack. This
can be used to abort an include.
#unpre

= Primitives Provided =

#pre
>number
parser
parse
include
needs
end.
#unpre} 1175294722


#--------------------------------------------------
# Ports

page Ports {This page lists the supported platforms and includes notes on building
for specific targets.

#---
Quick Summary:

* x86
** Linux
** Net, Free, Open, and DragonFly BSD
** OpenSolaris
** BeOS
** Cygwin
* ARM
** OpenBSD
** NetBSD
* MIPS
** NetBSD
** Linux

#---
= Linux =

* x86
* x86-64
* MIPS

Toka has been built and tested on Debian and SuSE, using
GCC versions 2.95, 3.0, and 4.1

#---
= BSD =

=== OpenBSD ===
* x86
* ARM (cats)

=== FreeBSD 4.x - 6.x ===
* x86

=== NetBSD 3 ===
* x86
* MIPS (pmax)
* ARM (cats)

=== DragonFly BSD ===
* x86

#---
= BeOS =
* x86
* FFI requires libdl.so (not standard part of BeOS)
** http://bebits.com/app/2917
* You <i>may</i> need a newer GCC
** http://bebits.com/app/4011
* <i>make beos</i>

#---
= Cygwin =
* x86
* Tested under Windows XP and Vista
* FFI may be buggy
* <i>make cygwin</i>

#---
= OpenSolaris =
* x86} 1176697155


#--------------------------------------------------
# Quotes

page Quotes {With the functions described above, many small programs can be written.
Toka has much more functionality, but before proceeding further, we need
to take a look at how to create new functions (called <i>quotes</i>).

In Toka, a <i>quote</i> is the basic building block. At the simplest
level, they are anonymous blocks of code and data. Quotes are created by
encolsing the code and/or data in brackets:

#pre
  [ ]
#unpre

The above will create an empty quote and leave a pointer to it on the
stack. You can attach a name to a quote with <b>is</b>:

#pre
  [ ] is empty-quote
#unpre

Names can include any characters, other than space, tab, cr, or lf (enter
key). (<i>There are other forms of <b>is</b>, but this is the most common
one; the others will be discussed later</i>).} 1177020262


#--------------------------------------------------
# quotes.c

page quotes.c {= Use =

Build, operate on quotes.

= Functions Provided =

#pre
Variables:
  QUOTE quotes[8]
  Holds details about the compiler state, heap,
  etc for quotes during compilation.

  long qdepth
  Tracks how deeply the quotes are nested

  long quote_counter
  Tracks the current loop index

  Inst top
  Holds a pointer to the root quote

begin_quote()
Create a new quote. This allocates space for it,
and sets the compiler flag. A pointer to the
quote's start is pushed to the stack.

end_quote()
Terminate the previously opened quote and perform
data_class() semantics.

invoke()
Call a quote (passed on TOS)

iterate()
Repeat execution of a quote (passed on TOS), NOS
number of times.

alt_iterate()
Repeat execution of a quote (passed on TOS), NOS
number of times.

truefalse()
Takes three items (true-xt, false-xt, and a flag)
from the stack. Stack should be passed in as:
  flag true false 
It will execute true if the flag is true, false
otherwise.

recurse()
Compiles a call to the top-level quote. As a
trivial example:
  [ dup 1 > [ dup 1 - recurse swap 2 - recurse + ] true? ] is fib

qlit()
Push the value in the following memory location
to the stack. This is used instead of lit() so
that the decompiler (and eventually debugger) can
reliably identify nested quotes as opposed to 
regular literals.

quote_index()
Return the current loop index (counter)

quote_while_true()
Return execution of a quote until the quote
returns FALSE.

quote_while_false()
Return execution of a quote until the quote
returns TRUE.
#unpre

= Primitives Provided =

#pre
[
]
recurse
i
whileTrue
whileFalse
invoke
iterate
+iterate
#unpre} 1176067286


#--------------------------------------------------
# Recent Changes

page {Recent Changes} {[@recentChanges@]} 1026585675


#--------------------------------------------------
# Sandbox

page Sandbox {This is place to experiment with Notebook's way of marking up text.
Edit this page to see how you type things; then save it to see what it looks
like when you're browsing.

= You Can Have Section Headers =

*	You can have bulleted lists.
*	You can type <b>bold</b>, <i>italic</i>, and <m>monospace</m> text,
	or any combination.
*   You can have <h>inline header text</h>.
*	You can have <s>very small</s> text.
*   You can <x>strike things out</x>.

:	You can simply indent a paragraph without adding a bullet.

Paragraphs end with the first blank line, bullet item, or indented line.
No matter how many lines long a paragraph is, Notebook will wrap it for
display so that it looks nice.

 If you leave a space character at the beginning of a paragraph, the whole
 paragraph is "Preformatted".  That means that it's displayed in a monospace
 font, exactly as is.  It's conventional to put whitespace at the beginning of
 every line of a preformatted paragraph, but that's not necessary.

Preformatted text is useful for typing in tables and things like that.} 1113419698


#--------------------------------------------------
# Search

page Search {[@searchIndex@]} 1175217539


#--------------------------------------------------
# stack.c

page stack.c {= Use =

Implements the basic stack operations. This is intentionally kept
minimal, though additional primitives can be added to improve overall
performance.

= Functions Provided =

#pre
stack_dup()
Duplicate the TOS

stack_drop()
Drop the TOS

stack_swap()
Exchange TOS and NOS

stack_to_r()
Push TOS to return stack, DROP TOS

stack_from_r()
Pop TORS to the data stack

stack_depth()
Return the number of items on the stack
#unpre

= Primitives Provided =

#pre
dup
drop
swap
>r
r>
depth
#unpre} 1176258218


#--------------------------------------------------
# threading model

page {threading model} {Toka relies on <i>call threading</i>. This is an implementation technique
in which a list of addresses is compiled. Each of these is then called in
sequence. The model is similar to <i>direct threading</i> in the Forth
world.

There is one special address which marks the end of a threaded sequence.
This address is <b>0</b>.

As an example of this, consider the following quote:

#pre
 [ a b c 1 2 + . ]
#unpre

This is compiled into a list of addresses:

#pre
 a, b, c, lit, 1, lit 2, +, ., 0
#unpre

Note the special form for numbers. The [lit()|vm.c] function pushes the value in
the following cell to the stack.

When this quote is invoked, <i>a</i> will be called. After it finishes
executing, <i>b</i> will be called, and so on until <i>0</i> is
encountered. At that point, the [vm_run()|vm.c] function exits.} 1176257425


#--------------------------------------------------
# toka.c

page toka.c {= Use =

Setup and call the interpreter.

= Functions Provided =

#pre
main()
The main entry point into Toka. Sets up the
dictionary and calls interpret().
#unpre

= Primitives Provided =

<i>None</i>} 1175294848


#--------------------------------------------------
# TokaDoc

page TokaDoc {= Introduction =

To help keep an up-to-date list of C functions and their Toka
equivilents, the TokaDoc scripts were developed. These seach C sources
for specially formatted comments and extract them into various files.
These files can be updated when [building].

= Supporting TokaDoc =

At the start of each C file, have a comment header like this:

#pre
 /*
  *|F|
  *|F| FILE: filename
  *|F|
  */
#unpre

Before any global variables, have a comment block like this:

#pre
/*
 *|F| Variables:
 *|F|   GCITEM gc_list[128]
 *|F|   Holds the list of items marked as garbage.
 *|F|
 */
#unpre

Before each function have a comment block like this:

#pre
 /*
  *|F| <return type> functioname(<arguments>)
  *|F| description of the function
  *|F|
  */
#unpre

And for any functions having a Toka equivilent, have a block like:

#pre
 /*
  *|G| wordname    stack-effect    description
  */
#unpre

Please try to keep columns lined up as much as possible for Toka wordlist comments.} 1175313140


#--------------------------------------------------
# User Code

page {User Code} {Use this page to extend Notebook using the 
[@helpbtn "the Tcl language"@].  Commands you add here can be used as
[@helpbtn "Magic Button"@]s and [@helpbtn "Embedded Macro"@]s.

Note that you can intersperse normal prose in between blocks of Tcl code.

= User Menu =

The [@helpbtn "User Menu"@] pops up when you right-click or control-click 
on a page in the [@helpbtn "Page Browser"@].  You can customize it however you like.

#Tcl
usermenu {
    Back back-page
    Home {goto-page Home}
}
#unTcl

= Edit Menu =

The [@helpbtn "Edit Menu"@] pops up when you right-click or control-click 
on a page in the [@helpbtn "Page Editor"@].  You can customize it however you like.

#Tcl
editmenu {
    Undo             undo-change
    Redo             redo-change
    separator {}
    Cut              cut-string
    Copy             copy-string
    Paste            paste-string
    "Insert Page..." insert-page
}
#unTcl

= Example =

The following [@helpbtn "embedded macro"@] used to be used by the
[Tour] to create a [@helpbtn "magic button"@] that said 
"Click here to continue..." and took you to the next page in the tour
when you clicked it.  It's no longer needed, because now you can write
such links directly, like this:

  [Click here to continue...|Tour 2]

Still, it's a nice example of how to write a macro that creates a button.

#Tcl
proc clickToContinue {name} {
	return "\[%Click here to continue...|goto-page [list $name]%\]"
}
#unTcl} 1113420734


#--------------------------------------------------
# UsingTheStack

page UsingTheStack {he language makes use of a stack to pass data between functions (called
<i>quotes</i> in toka). Imagine a stack of blocks with numbers on them.
You can add or remove numbers from the top of the stack. You can also
rearrange the order of the numbers.

The stack is initially empty. Let's start by putting some numbers on the
stack. Type in:

#pre
  23 7 9182
#unpre

Excellent! Now print the number on top of the stack using <b>.</b>, which
is pronounced "dot". This is a hard word to write about in a manual
because it is just a single period.

Enter:

#pre
  .
#unpre

You should see the last number you entered, 9182, printed. Each time
<b>.</b> is used, the top element on the stack is lost. If you want to
see what is on the stack, you can use <b>:stack</b>. Try this:

#pre
  :stack
#unpre

You should see:

#pre
  <2> 23 7
#unpre

The number on the left, enclosed in brackets, is the number of items on
the stack. The number to the far right is the top of the stack, or
<i>TOS</i>. It should be mentioned that <b>:stack</b> leaves the stack
unchanged.

Since Toka uses the stack to hold data being operated on, and it uses the
stack to pass data between quotes, it is very important to practice using
it. Quotes generally take what they need off of the stack, and put their
results back on it. To help understand exactly what each quote consumes
and leaves, we use <i>stack diagrams</i>. As an example:


#pre
  . ( x- )
#unpre

That is to say, <b>.</b> takes one word off the stack (the 'x') and puts
nothing on the stack. In other words, it consumes the TOS.

In the examples that follow, you do not need to type in the comments.
When you are programming, of course, liberal use of comments and stack
diagrams may make your code more readable and maintainable.

Between examples, you may wish to clear the stack. If you enter
<b>reset</b>, the stack will be cleared. Since the stack is central to
Toka, it is important to be able to alter it easily. Let's look at some
more functions that manipulate the stack. Enter:

#pre
  reset
  777 dup :stack
#unpre

You will notice that there are two copies of 777 on the stack. The quote
<b>dup</b> duplicates TOS. This is useful when you want to use the TOS
and still have a copy. The stack diagram for <b>dup</b> would be:

#pre
  dup ( x-xx )
#unpre

Another useful quote is <b>swap</b>. Enter:

#pre
  reset
  23 7 :stack
  swap :stack
#unpre

The stack should look like:

#pre
  <2> 7 23
#unpre

The stack diagram for <b>swap</b> would be:

#pre
  swap ( xy-yx )
#unpre

Now enter:

#pre
  over :stack
#unpre

You should see:

#pre
  <3> 23 7 23
#unpre

<b>over</b> causes a copy of the second item on the stack to leapfrog
over the first. Its stack diagram would be:

#pre
  over ( xy-xyx )
#unpre

Here is another commonly used function:

#pre
  drop ( x- )
#unpre

Can you guess what we will see if we enter:

#pre
  drop :stack
#unpre

Another handy function for manipulating the stack is <b>rot</b> (short
for rotate). Enter:

#pre
  11 22 33 44 :stack
  rot :stack
#unpre

The stack diagram for <b>rot</b> is, therefore:

#pre
  rot ( xyz-yzx )
#unpre

You have now learned the more important stack manipulation words. These
will be present in almost every non-trivial Toka program. I will say that
if you see heavy use of these words in your code, you may want to examine
and reorganize (<i>refactor</i>) your code. Use of variables and arrays
(which we will discuss later) can also help clean things up.

Here are stack diagrams for some other useful stack manipulation
functions. Try experimenting with them by putting numbers on the stack
and calling them to get a feel for what they do. Again, the text in
parentheses is just a comment and need not be entered.

#pre
  2drop ( xyz--x )
  2dup ( xy-xyxy )
  nip ( xyz-xz )
  tuck ( xy-yxy )
#unpre} 1177020020


#--------------------------------------------------
# Variables

page Variables {To hold data for longer periods of time than is practical with the stack,
variables can be used. Variables are pointers to memory locations large
enough to hold a number. There are two primary ways to create variables:

#pre
  variable foo
  variable bar
  variable baz
#unpre

The above would create three new variables, named <b>foo</b>, <b>bar</b>,
and <b>baz</b>. When creating multiple variables, it is more readable to
use <b>variable|</b> though:

#pre
  variable| foo bar baz |
#unpre

You can use <b>@</b> (fetch) and <b>!</b> (store) to alter the contents
of a variable:

#pre
  variable foo
  100 foo !
  foo @ .
#unpre

For reading/writing character-sized values, <b>c@</b> and <b>c!</b> are
also provided. A full list of functions for working with variables follows:

#pre
  variable ( "- )      Parse ahead and create a named entry
                       corresponding to a memory location
  variable| ( |- )     Parse and create variables until | 
                       is encountered.
  @        ( a-n )     Fetch the value from variable 'a'
  !        ( na- )     Store 'n' to variable 'a'
  c@       ( a-n )     Fetch a byte from variable 'a'
  c!       ( na- )     Store byte 'n' to variable 'a'
#unpre} 1177020319


#--------------------------------------------------
# vm.c

page vm.c {= Use =

Implements the heart of the virtual machine.

= Functions Provided =

#pre
Variables:
  Inst *heap
  Pointer into the current heap

  Inst *ip
  The instruction pointer

  long stack[100], rstack[100]
  The data and return stacks

  long sp, rsp
  The stack pointers

vm_run(Inst)
Run through a list of instructions
Side effects:
  modifes *ip

vm_stack_check()
Check for over/underflow and reset if detected
If the return stack over/underflows, exit Toka

push(long a)
Push a number to the stack.

lit()
Push the value in the following memory location
to the stack
#unpre

= Primitives Provided =

#pre
heap
#unpre} 1175294932


#--------------------------------------------------
# Words and Their Uses

page {Words and Their Uses} {= Primitives =

These are words that are built into the Toka executable. If the
<b>bootstrap.toka</b> can not be found, these are the only words 
that will be provided.

#pre
<<       ( ab-c )    Shift 'b' left by 'a' bits
>>       ( ab-c )    Shift 'b' right by 'a' bits
and      ( ab-c )    Perform a bitwise AND
or       ( ab-c )    Perform a bitwise OR
xor      ( ab-c )    Perform a bitwise XOR
#args    (  -n )     Return the number of arguments
arglist  (  -a )     Return a pointer to the 
                     argument list.
<        ( ab-f )    Compare 'a' and 'b', return
                     a flag
>        ( ab-f )    Compare 'a' and 'b', return
                     a flag
=        ( ab-f )    Compare 'a' and 'b', return
                     a flag
<>       ( ab-f )    Compare 'a' and 'b', return
                     a flag
.        ( n- )      Display the TOS
emit     ( c- )      Display the ASCII character
                     for TOS
type     ( a- )      Display a string
bye      ( - )       Quit Toka
#        ( n- )      Push the following cell to
                     the stack.
@        ( a-n )     Fetch the value in memory
                     location 'a'
!        ( na- )     Store 'n' to memory location
                     'a'
c@       ( a-n )     Fetch a byte from memory
                     location 'a'
c!       ( na- )     Store byte 'n' to memory
                     location 'a'
copy     ( sdc- )    Copy 'c' bytes from 's' to
                     'd'
cell-size ( -n )     Return the size of a cell
char-size ( -n )     Return the size of a char
:words   ( - )       Display a list of all named
                     quotes and data
:stack   ( - )       Display all values on the
                     data stack
:gc      (  -  )     Display information about
                     the garbage collection list
:see     (  "- )     Decompile the specified quote
is       ( a"- )     Attach a name to a quote
         ( a$- )     Non-parsing form
is-super ( a"- )     Attach a name to a quote
         ( a$- )     Non-parsing form
is-macro ( a"- )     Attach a name to a quote
         ( a$- )     Non-parsing form
is-data  ( a"- )     Attach a name to data memory
         ( a$- )     Non-parsing form
\        ( "-a )     Return a quote corresponding
                     to the specified word.
         ( $-a )     Non-parsing form
from     ( "- )      Set the library to import from
         ( $- )      Non-parsing form
import   ( n"- )     Import a function taking 'n'
                     arguments.
         ( n$- )     Non-parsing form
as       ( "- )      Rename the last defined word
         ( $-  )     Non-parsing form
file.open  ( $m-n )  Open a specified file with
                     the specified mode.
file.close ( n- )    Close the specified file handle
file.read  ( nbl-r ) Read 'l' bytes into buffer 'b'
                     from file handle 'n'. Returns
                     the number of bytes read.
file.write ( nbl-w ) Write 'l' bytes from buffer 'b'
                     to file handle 'n'. Returns
                     the number of bytes written.
file.size  ( n-s )   Return the size (in bytes)
                     of the specified file.
file.seek  ( nom-a ) Seek a new position in the
                     file. Valid modes are
                     START, CURRENT, and END. These
                     have values of 1, 2, and 3.
file.pos   ( n-a )   Return a pointer to the current
                     offset into the file.
keep     ( a-a )     Mark quotes/allocated memory
                     as permanent.
gc       ( - )       Clean the garbage
malloc   ( n-a )     Allocate 'n' bytes of memory
heap     ( -a )      Variable pointing to the top
                     of the local heap
compiler ( -a )      Variable holding the compiler
                     state
count    ( a-ac )    Return an address/count pair
                     for a string
+        ( ab-c )    Add TOS and NOS
-        ( ab-c )    Subtract TOS from NOS
*        ( ab-c )    Multiply TOS by NOS
/mod     ( ab-cd )   Divide and get remainder
base     ( -a )      Variable containg the current
                     numeric base
parser   ( -a )      Variable holding current parser
                     mode.
escape-sequences ( -a)  Variable determining if
                        escape sequences are used.
>number  ( a-nf )    Attempt to convert a string
                     to a number
parse    ( d-a )     Parse until the character 
                     represented by 'd' is found.
                     Return a pointer to the string
include  ( "- )      Attempt to open a file and
                     add it to the input stack.
         ( $- )      Non-parsing form
needs    ( "- )      Attempt to include a file
                     from the library (normally
                     /usr/share/toka/library)
         ( $- )      Non-parsing form
end.     ( - )       Remove the current file from
                     the input stack
[        ( -a )      Create a new quote
]        ( - )       Close an open quote
invoke   ( a- )      Execute a quote
iterate  ( na- )     Execute a quote 'n' times
+iterate ( na- )     Execute a quote 'n' times
t/f      ( fab- )    Invoke 'a' if 'f' flag is
                     true, 'b' if false.
recurse  ( - )       Compile a call to the top
                     quote.
i        ( -n )      Return the current loop index
whileTrue  ( a- )    Execute quote. If the quote
                     returns TRUE, execute again.
                     otherwise end the cycle.
whileFalse ( a- )    Execute quote. If the quote
                     returns FALSE, execute again.
                     otherwise end the cycle.
dup      ( n-nn )    Duplicate the TOS
drop     ( n- )      Drop the TOS
swap     ( ab-ba )   Exchange the TOS and NOS
>r       ( n- )      Push TOS to return stack, DROP
r>       ( -n )      Pop TORS to the data stack
depth    ( -n )      Return the number of items
                     on the stack
#unpre

= Bootstrap =

These are additional words, provided in <b>bootstrap.toka</b>.
They significantly expand the core language.

#pre
#!       ( "- )      Parse to the end of the line
                     and scrap the results.
SPACE    ( -n )      ASCII value for SPACE character
CR       ( -n )      ASCII value for CR character
LF       ( -n )      ASCII value for LF character
ESC      ( -n )      ASCII value for ESC character
TAB      ( -n )      ASCII value for TAB character
wsparse  ( -a )      Parse until a SPACE is encountered
lnparse  ( -a )      Parse to the end of the line,
                     leave the resulting string on the
                     stack.
FALSE    ( -f )      Value returned for FALSE
TRUE     ( -f )      Value returned for TRUE
true?    ( fq- )     Execute quote ('q') if flag ('f') is TRUE
false?   ( fq- )     Execute quote ('q') if flag ('f') is FALSE
>char    ( n-c )     Convert the value on TOS to a single character
char:    ( "-c )     Parse ahead and return one character
"        ( "-$ )     Parse until " is encountered and return a string
cr       ( - )       Display a CR character
space    ( - )       Display a space
tab      ( - )       Display a tab
t:       ( "- )      Parse to the end of the line, display
                     the results.
clear    ( - )       Clear the screen
normal   ( - )       Set the colors back to the default
bold     ( - )       Set the bold attribute for the foreground color
black    ( - )       Set the foreground color to black
red      ( - )       Set the foreground color to red
green    ( - )       Set the foreground color to green
yellow   ( - )       Set the foreground color to yellow
blue     ( - )       Set the foreground color to blue
magenta  ( - )       Set the foreground color to magenta
cyan     ( - )       Set the foreground color to cyan
white    ( - )       Set the foreground color to white
onBlack  ( - )       Set the background color to black
onRed    ( - )       Set the background color to red
onGreen  ( - )       Set the background color to green
onYellow ( - )       Set the background color to yellow
onBlue   ( - )       Set the background color to blue
onMagenta( - )       Set the background color to magenta
onCyan   ( - )       Set the background color to cyan
onWhite  ( - )       Set the background color to white
nip      ( xy-y )    Remove the second item on the stack
rot      ( abc-bca ) Rotate top three values on stack
-rot     ( abc-acb ) Rotate top three values on stack twice
over     ( xy-xyx )  Put a copy of NOS above the TOS
tuck     ( xy-yxy )  Put a copy of TOS under NOS     
2dup     ( xy-xyxy ) Duplicate the top two items on the stack
2drop    ( xy- )     Drop TOS and NOS
reset    ( *- )      Drop all items on the stack
r@       ( -x )      Get a copy of the top item on the return stack
1+       ( x-y )     Increase value on stack by 1
1-       ( x-y )     Decrease value on stack by 1
negate   ( x-y )     Invert the sign of TOS
/        ( xy-z )    Divide two numbers
mod      ( xy-z )    Divide two numbers and get remainder
not      ( x-y )     Invert the value 'x'
*/       ( abc-d )   (a*b)/c
chars    ( x-y )     Multiply TOS by char-size. Useful w/arrays
char+    ( x-y )     Increase TOS by char-size
char-    ( x-y )     Decrease TOS by char-size
cells    ( x-y )     Multiply TOS by cell-size. Useful w/arrays
cell+    ( x-y )     Increase TOS by cell-size
cell-    ( x-y )     Decrease TOS by cell-size
+!       ( xa- )     Add 'x' to the value in address 'a'
-!       ( xa- )     Subtract 'x' from the value in address 'a'
on       ( a- )      Set a variable to TRUE
off      ( a- )      Set a variable to FALSE
toggle   ( a- )      Toggle a variable between TRUE and FALSE
variable ( "- )      Create a variable
variable| ( "- )     Create multiple variables
hex      ( - )       Set the base to hexadecimal (16)
decimal  ( - )       Set the base to decimal (10)
binary   ( - )       Set the base to binary (2)
octal    ( - )       Set the base to octal (8)
"R"      ( -x )      Mode for file.open
"R+"     ( -x )      Mode for file.open
"W"      ( -x )      Mode for file.open
"W+"     ( -x )      Mode for file.open
"A"      ( -x )      Mode for file.open
"A+"     ( -x )      Mode for file.open
START    ( -x )      Mode for file.seek
CURRENT  ( -x )      Mode for file.seek
END      ( -x )      Mode for file.seek
file.slurp        ( $-a )   Read a file into a dynamically allocated buffer 
is-array          ( n"- )   Create an array of size 'n'
get-element       ( ia-n )  Get element 'i' from array 'a'
put-element       ( nia- )  Put value 'n' into element 'i' of array 'a'
get-char-element  ( ia-n )  Get char-size element 'i' from 
                            array 'a'
put-char-element  ( nia- )  Put char-size value 'n' into element 'i' of 
                            array 'a'
<list>   ( -a )      Stores a list of pointers used by { and }
{        ( - )       Start a scoped area
}        ( - )       End a scoped area
#unpre
} 1177177102


# End of Notebook Database File
