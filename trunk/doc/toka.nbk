# Notebook Database File

#--------------------------------------------------
# Arrays

page Arrays {The standard bootstrap adds support for arrays. These are a superset of
variables, and hold either character or numeric data.

The words provided are:

#pre
  is-array          n"-     Create an array of size n. Parses for the name.
  put-element       nia-    Put value (n) into array (a) at index (i)
  get-element       ia-n    Get the value (n) from array (a) at index (i)
  put-char-element  nia-    Put character value (n) into array (a) at index (i)
  get-char-element  ia-n    Get the character value (n) from array (a) at 
                            index (i)
#unpre

= Example =

#pre
  10 cells is-array foo
  0 foo get-element .
  100 0 foo put-element 
  10 1 foo put-element 
  0 foo get-element .
  1 foo get-element .
#unpre

= Tips =

* The command line arguments are stored in an array (*arglist*).
** At 0 is the name of the script
** Actual arguments start at 1.
* Be careful not to exceed the length of your array when giving an index} 1177366441


#--------------------------------------------------
# bits.c

page bits.c {= Use =

This file provides a handful of primitives for manipulating bits.

= Functions Provided =

#pre
lshift()
Shift TOS left by NOS bits

rshift()
Shift TOS right by NOS bits

and()
Perform a bitwise AND

or()
Perform a bitwise OR

xor()
Perform a bitwise XOR
#unpre

= Primitives Provided =

#pre
<<       ( ab-c )    Shift 'b' left by 'a' bits
>>       ( ab-c )    Shift 'b' right by 'a' bits
and      ( ab-c )    Perform a bitwise AND
or       ( ab-c )    Perform a bitwise OR
xor      ( ab-c )    Perform a bitwise XOR
#unpre} 1175295170


#--------------------------------------------------
# Building

page Building {To build Toka, you will need the following:

* GCC 2.9x, 3.x, or 4.x
* Make (Either GNU Make or a BSD Make should work)

For most people, the following should work. If it fails, try checking the
[Ports] page to see if there are any platform-specific instructions. The
process using Make:

#pre
  make
#unpre

The build system should be able to detect the need for libdl.so (Linux,
BeOS) or whether dlopen() and dlsym() are provided by libc.so (BSD). You
can also build a version without the [FFI], but this is not recommended
as it reduces the usefulness of Toka significantly. This can be done via:

#pre
  rm source/ffi
  make CFLAGS=-DNOFFI
#unpre

As a final note, some pieces of documentation can be updated automatically
as well:

#pre
  make docs
#unpre} 1177366685


#--------------------------------------------------
# class.c

page class.c {= Use =

This is where the [WordClasses] are implemented. It does not export any
functions directly to Toka.

= Functions Provided =

#pre
forth_class()
If compiling, compile the xt into the current
quote. If interpreting, call the word.

macro_class()
Always call the word

data_class()
If compiling, compile a call to lit() and then
inline TOS into the following location. Otherwise
leave TOS alone.

quote_macro_class()
Always invoke the quote.

quote_class()
Handler for quotes; this takes two cells, one
which is a call to this function, the other is
the pointer to the quote to invoke.

quote_forth_class()
Perform data_class() semantics, then, if 
compiling, compile a call to invoke(). Otherwise,
invoke() is called with the xt on TOS.
#unpre

= Primitives Provided =

<i>None</i>} 1177736547


#--------------------------------------------------
# cmdline.c

page cmdline.c {= Use =

Build the list of command line arguments that Toka programs can access.
This is a subset of the full arguments passed to the <b>toka</b> executable.

= Functions Provided =

#pre
Variables:
  long arg_count
  Holds the number of command line arguments

  char *arg_list[128]
  Holds the list of command line arguments. 

num_args()
Return the number of arguments, not including the
file names used to launch this program.

get_arg_list()
Return the number of arguments, not including the
file names used to launch this program.

build_arg_list(char *args[], long count)
Copy pointers to the command line arguments to
arg_list[]. Also sets arg_count.
#unpre

= Primitives Provided =

#pre
#args
arglist
#unpre} 1177367383


#--------------------------------------------------
# Commenting Code

page {Commenting Code} {It is generally a good idea to comment your code. Comments will make it
much easier to remember what's going on, can help you locate bugs, and
also be of significant benefit to others who may work on your code at a
later time.

Toka provides two ways to comment your code.

=== In The Listener ===

At the listener (the top level interpreter), you can use <b>#!</b>
comments. These are comments that start with <b>#!</b> and end at the end
of the current line. For example, I often start my programs with a short
information block such as the following:

#pre
  #! ---------------------------------------------------------------
  #! A small HTTP server for Toka
  #!
  #! Developed by:
  #!  Charles R. Childers
  #!  erider
  #!
  #! ---------------------------------------------------------------
#unpre

This style comment works well for blocks, and thus can be very useful at
the start of a function:

#pre
  #! ---------------------------------------------------------------
  #! get-request
  #! This reads a client request of up to 1k into the buffer. The
  #! number of bytes read is returned.
  #! ---------------------------------------------------------------
#unpre

<b>#!</b> comments can <i>not be used inside quotes</i>.

=== Inside Quotes ===

Inside a quote, you can use <b>( ... )</b> comments. These start with a
<b>(</b> and end when <b>)</b> is encountered. Unlike <b>#!</b> comments,
these can span multiple lines and be used inside of quotes. An example:

#pre
  [ 
    connection     (  -a )
    @              ( a-n )
    pClose         ( n-  )
  ] is end-connection
#unpre

In this example, each stack action is mapped out using a <i>stack
comment</i>. This is helpful when learning to use Toka, as it makes it
easier to visualize the stack at each step.} 1177715575


#--------------------------------------------------
# Conditionals

page Conditionals {Toka provides a few basic comparison primitives and one primitive for
handling conditional execution of code. The standard bootstrap also adds
two quotes that extend the conditional functions.

Basic examples:

#pre
  1 100 = [ 1 . ] ifTrue
  1 100 = [ 2 . ] ifFalse
  1 100 = [ 3 . ] [ 4 . ] ifTrueFalse
#unpre

The first case will invoke the quote if the flag returned by <b>=</b> is
TRUE. The second invokes the quote if the flag is FALSE, and the third
form invokes the <b>[ 3 . ]</b> quote if TRUE, or the <b>[ 4 . ]</b>
quote if FALSE.} 1177812670


#--------------------------------------------------
# conditionals.c

page conditionals.c {= Use =

Contains the implementation of the core conditionals. These are words
which do comparisons, and return a flag on the stack.

= Functions Provided =

#pre
less_than()
Compare TOS and NOS, return a flag.

greater_than()
Compare TOS and NOS, return a flag.

equals()
Compare TOS and NOS, return a flag.

not_equals()
Compare TOS and NOS, return a flag.
#unpre

= Primitives Provided =

#pre
<
>
=
<>
#unpre} 1175293903


#--------------------------------------------------
# console.c

page console.c {= Use =

Provide a very basic console interface. The provided interface is
intentionally kept to a minimum, a better console interface can be loaded later.

= Functions Provided =

#pre
dot()
Display the number on TOS using the current base
if possible.

emit()
Display the character TOS corresponds to. Consumes
TOS.

type()
Display the string TOS points to. Consumes TOS.

bye()
Quit Toka
#unpre

= Primitives Provided =

#pre
.
emit
type
bye
#unpre} 1175293981


#--------------------------------------------------
# Constants

page Constants {For data that does not change, a <i>constant</i> can be created as
follows:

#pre
  100 is-data OneHundred
  " /home/crc/htdocs/" is-data docroot
#unpre

The first example takes the number 100, and assigns a name (OneHundred)
to it. The name can now be used as a symbolic constant at the listener or
inside a quote. The second example creates a named pointer to a string,
which can also be used at the listener or inside quotes.

The use of constants is encouraged as it makes code easier to read and
maintain. They have minimal impact on performance, and are significantly
faster to use than variables.} 1177888754


#--------------------------------------------------
# data.c

page data.c {= Use =

These are words useful for accessing and modifying data.

= Functions Provided =

#pre
make_literal()
Compile a call to lit() and then place TOS into
the next memory location.

fetch()
Fetch the value in the memory location pointed to
by TOS.

store()
Store NOS into the memory location specified by
TOS.

fetch_char()
Fetch the value in the memory location pointed to
by TOS. This version reads a single byte.

store_char()
Store NOS into the memory location specified by
TOS. This version stores a single byte.

copy()
Copies 'count' bytes from 'source' to 'dest'. The
stack form for this is:
  source dest count
The memory locations can overlap.

cell_size()
Push the size of a cell to the stack.

char_size()
Push the size of a char to the stack
#unpre

= Primitives Provided =

#pre
char-size
cell-size
copy
c!
c@
!
@
#
#unpre} 1175294055


#--------------------------------------------------
# debug.c

page debug.c {= Use =

This provides a very small collection of simple tools that can be helpful
when trying to track down bugs. It is not intended to be a full-scale
debugging tool.

= Functions Provided =

#pre
words()
Display a list of all named words

display_stack()
Display all items on the stack.

gc_info()
Display information about Toka's memory use
#unpre

= Primitives Provided =

#pre
:words
:stack
:gc
#unpre} 1176258298


#--------------------------------------------------
# decompile.c

page decompile.c {= Use =

This allows for decompiling a quote and displaying the source needed to
recreate it. 

= Functions Provided =

#pre
long resolve_name(Inst xt)
Search for a name in the dictionary that corresponds
to 'xt'. Display it if found, and return a flag.

decompile(Inst *xt)
Decompile a quote and its children and display the
result on the screen.

see()
Decompile the quote on the stack.
#unpre

= Primitives Provided =

#pre
:see
#unpre} 1175294160


#--------------------------------------------------
# dictionary.c

page dictionary.c {= Use =

This file provides the functionality to create new dictionary entries and
search for a specific entry.

= Functions Provided =

#pre
Variables:
  ENTRY dictionary[4096];
  Holds the dictionary entries, up to 4096

  long last
  A pointer to the most recent dictionary entry

add_entry(char *name, Inst xt, Inst class)
Add an entry to the dictionary.

name_attach(void *class)
Attach a name (from the input stream) to the 
specified quote address. This word is given the
semantics of the specified class.

name_quote()
Attach a name (from the input stream) to the 
specified quote address. This word is given the
semantics of quote_forth_class().

name_quote_macro()
Attach a name (from the input stream) to the 
specified quote address. This word is given the
semantics of quote_macro_class().

name_data()
Attach a name (from the input stream) to the data
at the specified address. Semantics are the same
as the data_class().

find_word()
Search for a word (name taken from the string
passed on TOS) in the dictionary. Returns the
xt, class, and a flag of -1 if found. If not
found, returns only a flag of 0.

return_quote()
Find a name (from the input stream) and return a
quote that corresponds to the word.
#unpre

= Primitives Provided =

#pre
is
is-data
is-macro
`
last
#unpre} 1177736642


#--------------------------------------------------
# ErrorCodes

page ErrorCodes {= E0 =
Nonfatal. This error is when a token can not be found in the dictionary
or converted to a number.

= E1 =
<b>Fatal</b>. This error is when the garbage collector fails to allocate enough
memory to fill a <b>[gc_alloc()|gc.c]</b> request.

= E2 =
Nonfatal. This error is given when an alien function (handled by the
[FFI]) is invoked with too many arguments for Toka to handle. You
shouldn't see it often.

= E3 =
Nonfatal. This error arises when a library can not be located for opening
by the [FFI]. 

= E4 =
Nonfatal. This error arises when a symbol can not be found in the
currently open library.

= E5 =
<b>Fatal</b>. When the return stack overflows or underflows, this error
is thrown and Toka exits.

Nonfatal. When the data stack overflows or underflows, this error is
thrown and Toka resets the stack pointer to the beginning of the stack.} 1177189326


#--------------------------------------------------
# errors.c

page errors.c {= Use =

This is where errors are handled. It does not export any functions
directly to Toka.

= Functions Provided =

#pre
error(long code)
Display a given error by code
#unpre

= Primitives Provided =

<i>None</i>

= See Also =

[ErrorCodes]} 1177189370


#--------------------------------------------------
# FFI

page FFI {To allow use of external libraries, Toka provides a simple <i>Foreign
Function Interface</i> (FFI). This is built around the following
primitives:

#pre
  from LIBRARY
#unpre

Set the import source to LIBRARY. This should be a fully-qualified
filename; it may require a path as well as the .so extension.

#pre
  N import FUNCTION
#unpre

Import FUNCTION from the previously specified library. A new quote named
FUNCTION will be created, and will take <i>N</i> arguments off the stack.
This function will always have a return value, even for <i>void</i>
functions.

You can also make use of <b>as</b> to rename the imported function.

#---
Example:

#pre
  #! Linux libc = libc.so.6, BSD libc = libc.so
  from libc.so.6
  2 import printf as printf.2
  " %i\n" 100 printf.2
#unpre

#---
The FFI is optional, and can be disabled at build time. Doing so reduces
the overall functionality of Toka, so doing this is only recommended if
you are using a system without dlopen()/dlsym(), or if you need more 
direct control over the functionality provided. To build a version of
Toka without the FFI, do:

#pre
  rm source/ffi.c
  make CFLAGS=-DNOFFI
#unpre

Again, <i>this is only recommended if your system does not support
dlopen()/dlsym()</i>.} 1177901033


#--------------------------------------------------
# ffi.c

page ffi.c {= Use =

Implements the [Foreign Function Interface|FFI], which allows use of external
libraries.

= Functions Provided =

#pre
Variables:
  void *library
  Pointer to the most recently opened library

ffi_invoke()
Call a foreign function. This translates between
Toka and CDECL calling conventions.

ffi_from()
Select a library to load from.

ffi_import()
Import and name an external function. This wraps
the imported function in a quote.

ffi_rename()
Rename the most recently defined word in the
dictionary.
#unpre

= Primitives Provided =

#pre
from
import
as
#unpre} 1176257909


#--------------------------------------------------
# Files

page Files {Toka provides functionality roughly identical to the standard C file I/O
functionality (fopen, fread, etc). 

#pre
  file.open  ( $m-n )  Open a specified file with
                       the specified mode.
  file.close ( n- )    Close the specified file handle
  file.read  ( nbl-r ) Read 'l' bytes into buffer 'b'
                       from file handle 'n'. Returns
                       the number of bytes read.
  file.write ( nbl-w ) Write 'l' bytes from buffer 'b'
                       to file handle 'n'. Returns
                       the number of bytes written.
  file.size  ( n-s )   Return the size (in bytes)
                       of the specified file.
  file.seek  ( nom-a ) Seek a new position in the
                       file. Valid modes are
                       START, CURRENT, and END. These
                       have values of 1, 2, and 3.
  file.pos   ( n-a )   Return a pointer to the current
                       offset into the file.
  file.slurp ( $-a )   Read file '$' into a new buffer.
  "R"        ( -x )    Mode for file.open
  "R+"       ( -x )    Mode for file.open
  "W"        ( -x )    Mode for file.open
  "W+"       ( -x )    Mode for file.open
  "A"        ( -x )    Mode for file.open
  "A+"       ( -x )    Mode for file.open
  START      ( -x )    Mode for file.seek
  CURRENT    ( -x )    Mode for file.seek
  END        ( -x )    Mode for file.seek
#unpre

= Examples =

#pre
  variable fid
  " /etc/motd" "R" file.open fid !
  fid @ file.size .
  fid @ file.close

  " /etc/motd" file.slurp [ type cr ] ifTrue
#unpre} 1177812690


#--------------------------------------------------
# files.c

page files.c {= Use =

Allows for reading and writing data to files.

= Functions Provided =

#pre
file_open()
Open a file using the specified mode. Modes are
a direct map to the fopen() modes: "r", "r+", "w",
"w+", "a", and "a+". Numeric values for these are
1 - 6, in that order.

file_close()
This is just a simple wrapper over fclose().

file_read()
This is just a simple wrapper over fread().

file_write()
This is just a simple wrapper over fwrite().

file_size()
This is just a simple wrapper over fstat() which
returns the size of the file.

file_seek()
This is just a simple wrapper over fseek().

file_pos()
This is just a simple wrapper over ftell().
#unpre

= Primitives Provided =

#pre
file.open
file.close
file.read
file.write
file.size
file.seek
file.pos
#unpre} 1175294463


#--------------------------------------------------
# First Steps

page {First Steps} {At present, Toka provides a basic <i>listener</i> as the only interface.
This is a console-based enviroment where you can type commands and get
instant feedback. Let's get started:

#pre
  crc@strider: toka
#unpre

If you built and installed Toka properly, it should start, displaying a
message like:

#pre
  toka (svn build)
#unpre

At this point, you can begin entering code. Let's start by exploring the
enviroment a little:

#pre
  :names
#unpre

Invoking <b>:names</b> will display all named elements in the currently
running Toka. Don't panic at the number of items -- you only need to
learn a handful of them to write code in Toka.

Now let's delve into actually using Toka a bit.

=== Introductory Bits ===
* [The Stack|UsingTheStack]
* [Basic Math|MathOperations]

=== Writing Functions ===
* [Quotes]
* [WordClasses]
* [Loops]
* [Conditionals]

=== Data Structures ===
* [Types]
* [Constants]
* [Variables]
* [Arrays]

=== Interfacing with the World ===
* [Files]
* [FFI]
* [Scripts]
* [Libraries]

=== Practical Matters ===
* [Commenting Code]
* [Stack Comments]} 1177900864


#--------------------------------------------------
# FloatsLibrary

page FloatsLibrary {This library adds support for floating point numbers and math. As with
many Forth implementations, it provides a separate stack for floating
point numbers, and alternative versions of the main stack and math words.
 
#pre
  float:    ( "-n )     Parse ahead for a new floating point
                        number
  fvariable ( "- )      Create a new floating-point variable
  f@        ( a-n )     Fetch the value in memory location 'a'
  f!        ( na- )     Store 'n' to memory location 'a'
  fdup      ( n-nn )    Duplicate the TOS
  fdrop     ( n- )      Drop the TOS
  fswap     ( ab-ba )   Exchange the TOS and NOS
  fdepth    ( -n )      Return the number of items on the stack
  fnip      ( xy-y )    Remove the second item on the stack
  frot      ( abc-bca ) Rotate top three values on stack
  f-rot     ( abc-acb ) Rotate top three values on stack twice
  fover     ( xy-xyx )  Put a copy of NOS above the TOS
  ftuck     ( xy-yxy )  Put a copy of TOS under NOS     
  f2dup     ( xy-xyxy ) Duplicate the top two items on the stack
  f2drop    ( xy- )     Drop TOS and NOS
  freset    ( *- )      Drop all items on the stack
  f+        ( ab-c )    Add TOS and NOS
  f-        ( ab-c )    Subtract TOS from NOS
  f*        ( ab-c )    Multiply TOS by NOS
  f/        ( ab-c )    Divide and get remainder
  :fstack   ( - )       Display all items on the float stack
  f.        ( n- )      Display the top item on the float stack
#unpre

=== Example ===

#pre
  needs floats
  float: 100
  float: 200.12
  f+
  f.
#unpre} 1178151284


#--------------------------------------------------
# garbage collector

page {garbage collector} {The Toka implementation makes heavy use of dynamically allocated memory.
To help avoid memory leaks, the memory allocation provides a very simple
form of <i>garbage collection</i>.

The model is very simple. A list containing pointers to each allocation,
and the corresponding size (in bytes) is kept. Each time memory is
requested, the code adds the request to the list. When the list is filled,
or if the allocation fails, the 16 oldest items are freed and all later
entries are shifted down.

Obviously there is also a way to mark entries as permanent. This is done
by <b>keep</b> (the <b>[gc_keep()|gc.c]</b> function). This routine skims
through the list of allocations (from most recent to oldest) looking for
a specific pointer. When found, that entry (and any subsequent
allocations -- in Toka these will almost always be subquotes, strings,
etc) are removed from the list.

In actual practice things are just a little more complex. Toka actually
maintains two lists; one for general allocations and a second one for
internal use. The second one is only used for allocations that are known
to be temporary. 

In addition, the code will always leave the 16 newest allocations in each
list alone to prevent them from falling out of scope.
 
Information regarding the current status of the garbage collection
subsystem can be obtained via <b>:gc</b> (the <b>[gc_info()|debug.c]</b> function).} 1176697195


#--------------------------------------------------
# gc.c

page gc.c {= Use =

Implements the memory allocator and basic [garbage collector].

= Functions Provided =

#pre
Variables:
  GCITEM gc_list[128]
  Holds the list of items marked as garbage

  long gc_depth
  A pointer to the top of the garbage collection
  list

  GCITEM gc_trash[128]
  Holds the short list of items marked as garbage

  long gc_tdepth
  A pointer to the top of the short garbage
  collection list

  long gc_used
  Contains the total size of all currently used
  memory, including permanent quotes.

  long gc_objects
  Contains the total number of objects that are
  currently existing, including permanent ones.

gc_alloc(long items, long size, long type)
Allocate the requested memory and add it to the
garbage collection list.
If type is set to 0, add to the normal garbage
collection list. If set to 1, add to the short
list of known garbage items which can be safely
freed at the next gc().
If the allocation fails, gc() is called, and the
allocation is retried. If it still fails, an
error is reported and Toka is terminated.

gc_keep()
Remove the specified address (and any childern it
has registered) from the garbage collection list.
If the TOS is not an allocated address, this will
silently ignore it.

gc()
Free the oldest allocations on the garbage list.
Will free up to 16 items from each list per
call. If there are 16 or less items remaining,
this code will leave the allocations alone.

toka_malloc()
Allocate TOS bytes of memory. Returns a pointer to
the allocated memory.
#unpre

= Primitives Provided =

#pre
keep
gc
malloc
#unpre} 1177180123


#--------------------------------------------------
# Home

page Home {Hello, and welcome to Toka!

Toka is an experimental language related to Forth. It is still under
development, and will continue to evolve over time. 

Don't expect your existing knowledge to apply directly to Toka. It allows
a good deal of low-level control, while supporting some useful
abstractions that make development easier. Some influences come from
RetroForth, HelFORTH, 4p, Factor, and SmallTalk.

<i>If you can't find something, try the [index]. A more structured set of
topics can be found in [First Steps].</i> 

= General Topics =

* [License]
* [Building] and [Installation]
* [First Steps]
* [Words and Their Uses]
* [Ports]

= Tutorial =
* [Tutorial] - About the tutorial
* [Lesson 0] - Motivation and Basic Syntax 
* [Lesson 1] - Stack and Numbers 
* [Lesson 2] - Stack diagrams and Comments 
* [Lesson 3] - Arithmetic Operators and Calculations 
* [Lesson 4] - Making New Definitions 
* [Lesson 5] - Introspection 
* [Lesson 6] - Variables and Data Storage 
* [Lesson 7] - Control Structures 
* [Lesson 8] - Strings 

= Internals =

=== Topics ===

* How the [garbage collector] works
* How the [parser] works
* Notes on the [threading model]
* Using [TokaDoc] to comment C code
* [ErrorCodes] that can arise
* [Limitations]

=== Source Files ===

* [bits.c]
* [class.c]
* [cmdline.c]
* [conditionals.c]
* [console.c]
* [data.c]
* [debug.c]
* [decompile.c]
* [dictionary.c]
* [errors.c]
* [ffi.c]
* [files.c]
* [gc.c]
* [initial.c]
* [interpret.c]
* [math.c]
* [parser.c]
* [quotes.c]
* [stack.c]
* [toka.c]
* [vm.c]} 1178672839


#--------------------------------------------------
# Index

page Index {[@pageIndex@]} 1026586734


#--------------------------------------------------
# initial.c

page initial.c {= Use =

Build the initial dictionary

= Functions Provided =

#pre
build_dictionary()
Attach names and classes to the various initial
words in the Toka language.
#unpre

= Primitives Provided =

<i>None</i>} 1175294584


#--------------------------------------------------
# Installation

page Installation {To get the most out of Toka, it needs to be installed. This can be done
via the build system:

#pre
  make install
#unpre

When done this way, the following files are installed:

#pre
  /usr/bin/toka
  /usr/share/toka/bootstrap.toka
#unpre

After installation, run the test suite:

#pre
  make tests
#unpre

Look for any failures in the test.log. If you encounter a problem, please
forward the test.log to charles.childers@gmail.com along with some
basic information about your system (OS, CPU type, GCC version, Toka
revision #)} 1177366737


#--------------------------------------------------
# interpret.c

page interpret.c {= Use =

The interpreter itself.

= Functions Provided =

#pre
Variables:
  long compiler
  When set to 0, interpret; when set to -1, 
  compile. This is checked by the various word
  classes defined in class.c

  char *scratch
  Temporary holding area used by the parser and
  other routines.

  char *tib
  Pointer to the text input buffer.

count()
Perform strlen() on the string passed on TOS. This
returns the string and the count on the stack. The
count is increased by 1 to include the trailing 
ASCII 0.

interpret()
Accept and process input.
#unpre

= Primitives Provided =

#pre
compiler
count
#unpre} 1177177233


#--------------------------------------------------
# Lesson 0

page {Lesson 0} {= Why Bother? =

Toka is weird compared to most popular computer languages. Until you
learn how, it is hard to read because it is not based on the syntax of
algebraic expressions.

But it is worth learning because a running Toka system gives you an
extraordinary degree of low-level control over the system. Unlike most
other programming environments that put up walls to hide or block access
to "unauthorized" things, Toka makes it easy to get at anything, at any
level from low to high.

= Toka Syntax =

Here is syntactically-valid line of Toka code: 

#pre
 this is a test 123 456
#unpre

Don't try to guess what it does; in fact it doesn't necessarily actually
work, because some of the symbols might not be defined. But it is
syntactically valid. It consists of 6 words, "this" "is" "a" "test" "123"
"456". Words are separated by white space - spaces, tabs, and newlines.
In most cases, spaces and newlines are the same.

Another syntactically valid line: 

#pre
 asdf  foo  jello  @W#$%^,T/%$  1a2qw2   gibbet
#unpre

That's 6 words. One of them is pretty strange, consisting mostly of
punctuation, but it is a word nevertheless. Any string of printing
characters is a word. Toka limits word names to 255 characters.
 
= Left to Right Execution =

The Toka interpreter is very simple. It parses the next word (i.e. it
skips whitespace, then collects characters until it sees another
whitespace character) and executes it.

That is it in a nutshell. So if you are trying to understand a Toka
program in detail, you have to look at each word in turn and work out
what it does. That sounds simple, but it will trip you up if you insist
on looking for algebra. Just go left to right, one word at a time.

With practice, you will learn enough of the Toka vocabulary (the meanings
of standard words) so that you can see what is going on at a glance,
without having to puzzle out each individual word. It is just like
learning to read - it is tedious until you get the basic vocabulary down,
then it is easy. 

<i>Thus endeth the lesson.</i>} 1178666311


#--------------------------------------------------
# Lesson 1

page {Lesson 1} {= Review =

In the previous lesson we learned that: 
* The top-level parser only looks for whitespace, so Forth words must be
  separated by one or more spaces
* Execution proceeds from left to right. Get a word, execute it. 

Today we will start trying some commands. 

= The Stack =

Toka has an explicitly visible stack that is used to pass numbers between
words (commands). Using Toka effectively requires you to think in terms
of the stack. That can be hard at first, but as with anything, it becomes
much easier with practice.

Toka also has a secondary stack - the "return stack" - that is used for
return addresses and a few other things. Toka automatically manages the
return stack so you don't have to think about it for the most part (but
you can get at it if you need to; Toka doesn't block you from doing
anything). 

== Displaying the Stack ==

#pre
  :stack
#unpre

Doing this will cause Toka to show you what is on the stack. If the stack
contained the numbers 5678 and 112233, you would see:

#pre
 <2> 5678 112233
#unpre

The number to the right is the top of the stack and the number in
brackets on the left is the number of items on the stack. 

== Putting Numbers on the Stack ==

If you type a number, it gets pushed onto the stack: 
#pre
 12345 998877
 :stack
 <2> 12345 998877
#unpre

What we see here is that the two numbers did get pushed onto the stack,
and since <b>:stack</b> was called, the stack contents were displayed.

= First Words =

#pre
 12345 998877 + :stack
 <1> 1011222
#unpre

The <b>+</b> word pops two numbers from the stack, adds them, and pushes
the sum back on the stack. Note that: 

* + doesn't display the result, it just pushes the result back on the stack. In this case, however, we are assuming that "showstack" mode is on, so the interpreter displayed the stack for us automatically before the next prompt. 
* The numbers are in decimal. Toka can operate in bases 2, 8, 10, and 16,
  however it can not display binary numbers at present. The default base
  is decimal. You can change the base at any time by typing <b>hex</b> or
  <b>decimal</b>. All of the examples in this tutorial series will use
  decimal as the default base.
* The current number base applies to both number input and number output. 

= Displaying Numbers =

#pre
 12345
#unpre

Now the number is on the stack. It can be displayed:

#pre
 :stack
 <1> 12345
 :stack
 <1> 12345
#unpre

<b>:stack displays the entire stack, non-destructively. 

#pre
 12345
 .
 12345
 :stack
 <0>
#unpre

<b>.</b> pops the top of the stack and displays that number. Afterwards,
the number is no longer there.


= How the Interpreter Works =

The Toka interpreter is very simple. It just does this over and over: 

* Read a line of input 
* While there is more data in the line: 
* Parse a whitespace-delimited word 
* Lookup the word in a list of defined words. If found, execute the code
  for that word. 
* Otherwise, try to interpret the word as a number in the current number
  base. If so, push it on the stack. 
* Otherwise display an error message 

<i>Thus endeth the lesson.</i>} 1178666959


#--------------------------------------------------
# Lesson 2

page {Lesson 2} {= Review =

In the previous lesson we learned to: 

* Display the stack with <b>:stack</b> 
* Push numbers on the stack by typing them 
* Control the number base with <b>hex</b> and <b>decimal</b> 
* Execute words by typing their names 

= Stack Diagrams =

Pay attention to this section because it introduces notation that will be
used over and over.

Since Toka words use the stack for arguments and results, their
description must tell you the arguments that they pop from the stack and
the results that they push back on the stack. That is done with a <i>stack
diagram</i>.

#pre
 +  ( n1 n2 -- n3 )
#unpre

That indicates that the Toka word <b>+</b>, which we saw in the last lesson,
pops two numbers n1 and n2 from the stack and pushes back one number n3.
The list of items before the "--" is the arguments, the list after is the
results. In each list, the items at the right is the top of the stack.

In general, Toka words can take any number of arguments and leave any
number of results.

This is purely a notation convention. The Toka interpreter does not
process stack diagrams other than to skip them. The way it knows to skip
them is because the Toka word <b>(</b> introduces a comment, which is
terminated by the next <b>)</b>. 

Another example:

#pre 
 :stack  ( -- )
#unpre

That means that <b>:stack</b> has no net stack effect. It doesn't pop
anything off the stack (no arguments) and it doesn't leave any extra
items on the stack after it finishes. It might push and pop numbers while
it is executing, but when it is done, the stack is the same as it was
before.

#pre 
 .  ( n -- )
#unpre

The word <b>.</b> (which displays a number), pops its one argument from the
stack and leaves nothing in its place.

The names in the argument and result lists (e.g. "n1", "n2", "n3") are
arbitrary, but as an aid to understanding, they are often chosen to
convey extra information. For example: 

#pre
 type  ( adr -- )
#unpre

We haven't seen the word <b>type</b> yet, but clearly it takes one
argument, an address. It pops the argument from the stack, leaving
nothing in its place. 

Conventionally, stack item names beginning with "n" refer to signed
integers, "u" to unsigned integers, "d" to double numbers (two stack
numbers interpreted as a 64-bit integer), "adr" to addresses, "flag" to
values that are either true (0xfffffff) or false (0). But that is not a
hard and fast rule.

Toka also has a shorter form of stack comments that is often used. See
[Stack Comments] for further details on the short form.

= How Comments Work =

The following is in some sense an implementation detail, but it's good to
understand it, because it is key to Toka's approach to syntax, which is
vastly different to most other languages.

In the section above I mentioned that the word <b>(</b> skips to the next
<b>)</b>. That might seem like an exception to the rule that the
interpreter only parses whitespace-delimited words, but it is not.

What actually happens is that the main interpreter loop only sees the
<b>(</b>. The <b>(</b> must be followed by whitespace, otherwise the
interpreter will not parse just </b>(</b> but rather some longer string
beginning with </b>(</b>. The interpreter then looks in the list of
defined words for one named <b>(</b>, and executes it.

The behavior of the <b>(</b> word is to call the parser, asking it to collect a sequence of characters delimited by <b>)</b>, and then to discard the result. So
Any word can call the input parser, not just the main interpreter.

The parser itself can use any character as a delimiter, not just
whitespace. The main interpreter only asks the parser for
whitespace-delimited words, but other words can and do parse using other
delimiters.

This same approach (main interpreter calls a word that then parses using
a different delimiter) is also used for string literals where the
delimiter is <b>"</b>. 

You can, if you wish, call the parser yourself from user code, to collect
any kind of string you want. It's best to use this capability sparingly
to avoid confusion, but it illustrates the fact that the entire Toka
system is available to you; nothing is magic or hidden.

= Comment to End of Line =

The <b>( .... )</b> comment form stops at the <b>)</b>; stuff after it will be interpreted as usual. To comment out everything else on the line, use <b>#!</b>. 

#pre
 #! everything after the first #! will be ignored
#unpre

Note that the <b>#!</b> must be followed by whitespace, because <b>#!</b>
is just a word like anything else. The way that <b>#!</b> works is to
call the parser with a delimiter value (10) that matches a line ending
character, discarding the result. The parser will stop at the end of the
line, having found the delimiter. 

<i>Thus endeth the lesson</i>} 1178668132


#--------------------------------------------------
# Lesson 3

page {Lesson 3} {= Review =

In the previous lesson we learned that: 
* Toka words are described by stack diagrams like: ( argn .. arg0 --
  resultm .. result0 ) 
* Comments are either <b>( this is a comment )</b> or <b>#! the rest of the line is a comment</b>
* Both <b>(</b> and <b>#!</b> must be followed by whitespace 
* Comments work by executing a word that then explicitly calls the input parser 

= Arithmetic and Logical Operators =

We have already seen <b>+</b>, which pops two numbers, adds them, and
pushes the result. Here are some more numeric operators with their stack
diagrams:

#pre
 +       ( n1 n2 -- n1+n2 )
 -       ( n1 n2 -- n1-n2 )
 *       ( n1 n2 -- n1*n2 )   \ Signed multiplication
 /       ( n1 n2 -- n1/n2 )   \ Signed division
 mod     ( n1 n2 -- n1%n2 )
 /mod    ( n1 n2 -- n1%n2 n1/n2 )
 and     ( n1 n2 -- n1&n2 )
 or      ( n1 n2 -- n1|n2 )
 xor     ( n1 n2 -- n1^n2 )
 <<      ( n1 n2 -- n1<<n2 )  \ Shift bits left
 >>      ( n1 n2 -- n1>>n2 )  \ Shift bits right
 not     ( n -- ~n )          \ Bitwise logical inversion
 negate  ( n -- -n )          \ Arithmetic negation, i.e. 0-n
 1-      ( n -- n-1 )         \ Decrement by 1
 1+      ( n -- n+1 )         \ Increment by 1  
#unpre

All of the above operators work on integers of the natural size for the
machine (32 bits on 32-bit processors). 

= Using Toka as a Calculator =

Armed with those operators, plus the <b>.</b> (pop and display) word that
we have already seen, we can use Toka as an integer calculator. But since
everything is stack based, we have to use Reverse Polish instead of
algebraic syntax. Instead of writing down an algebraic expression with
parentheses to control the grouping, we have to think about what to do
first, and then do it.

So, suppose that we want to calculate ( 5 + ( 4 * 7 ) ). The
multiplication has to be done first, before we can add the 5. We could
perform that calculation in Toka with:

#pre
 4 7 * 5 + .
#unpre

Breaking this down into the individual steps, 

* push 4 on the stack 
* push 7 on the stack 
* pop two items from the stack, multiply them, and push the result (28)
  back on the stack 
* push 5 on the stack 
* pop two items from the stack, add them, and push the result (33) back
  on the stack
* pop the stack and display it 

The same calculation can be written in a different way 

#pre
 5 4 7 * + .
#unpre

In this version, we push all three numbers onto the stack at once, then
perform the arithmetic - first the multiplication of 4 and 7, and finally
the addition of 5 to the product.

The key to using RPN is that you have to think in terms of doing steps in
order instead of writing a picture of the algebraic expression and
letting the compiler sort it out.

= Stack Operators =

Sometimes you need to copy or rearrange the stack to bring items to the
correct position for further use. Four basic stack operators get the most
use. 

#pre
 dup  ( a -- a a )
 drop ( a -- )
 swap ( a b -- b a )
 over ( a b -- a b a )
#unpre

Stack operators will be examined in more detail in a later lesson. 
 
<i>Thus endeth the lesson</i>} 1178668498


#--------------------------------------------------
# Lesson 4

page {Lesson 4} {= Review =

In the previous lesson we learned that: 

* Forth has the usual collection of integer arithmetic and logical operators 
* You have to do calculations in postfix (Reverse Polish) form 

= Making New Words =

So far we have done everything interactively, using only numbers and
predefined words - and only a miniscule fraction of the predefined words
that exist. Now we will learn how to make our own new words.

Suppose that we want to add 12345 to several other numbers and display
the results. Using just what we have learned so far, we could write:

#pre
 55 12345 + .
 12400
 2442 12345 + .
 14787
#unpre

and so on. This wouldn't even be particularly tedious if you use a tool
like <i>rlwrap</i> to provide command line history and editing. But we
want to learn to make new words, so we will.

#pre
 [ 12345 + . ] is foo
 55 foo
 12400
 2442 foo
 14787
#unpre

We made a new word "foo" whose behavior is the same as "12345 + ." . Now
"foo" can be used just the same as any other word in the system. Here's
how the process works:

The Toka word <b>&lb;</b> (which must be followed by whitespace, just like
every other word) creates a new <i>quote</i> and sets the interpreter to
<i>compile state</i> (normally the interpreter is in <i>interpret
state</i>). In compile state, instead of executing each word that it
encounters, the interpreter compiles the behavior of the encountered word
into the body of the new word. When it sees a number in compile state,
the interpreter compiles code that will push that number on the stack
when the new word later executes. When the interpreter encounters
<b>&rb;</b>, it compiles something akin to "return from subroutine" and
switches back to interpret state. The word <b>is</b> parses for a
whitespace delimited token and creates a new name using this token and
attaches the quote to it.

What about arguments and results? Well, since the stack is used for
passing arguments, everything just works. The <b>+</b> that is compiled
inside "foo" can pop two numbers off the stack (e.g. the "55" that was
pushed outside of foo, and the "12345" that was pushed earlier during the
execution of foo), in the same way as it would if you executed "+"
directly from the interpreter.

But wait, you say, what about the return address that is necessary to get
back when foo executes? Doesn't that go on the stack, and thus interfere
with the numbers? No, because a separate stack (the "return stack") is
used for return addresses. 

= Compiled Code =

What does the compiled code (inside the new word "foo") look like? Well,
the Toka language doesn't specify that. It just says that the result of
executing "foo" has to be the same as if you executed its constituent
words. Different Toka implementations can use different code generation
strategies. Some may generate optimized machine language code. Others
may generate machine language code that consists of a sequence of subroutine
calls, one call to each constituent word. Perhaps the most common
approach is "threaded code", in which the body of "foo" consists of an
array of addresses, one for each constituent. A tiny "tree walker"
machine language code sequence grabs each address in turn and jumps to
it. Each approach has its advantages and disadvantages. Threaded code
offers a good balance between speed, compactness, simplicity,
portability, and ease of debugging. 

= Redefinitions =

What happens if you try to make a new word that has the same name as an
existing one? Perhaps surprisingly, Toka will let you do that. Consider:

#Pre
 [ 5678 . ] is word1
 word1
 5678
 [ word1 123 . ] is word2
 word2
 5678 123
 [ 999 . ] is word1 
 word1
 999
 word2
 5678 123
#unpre

Whoa! This is weird! Or is it? 

First we create "word1" that displays "5678". Then we create "word2" that
calls "word1" then displays "123". So far so obvious.

Now we create "word1" again. Now when we interpret "word1" we see "999"
instead of "5678". But when we interpret "word2", it still shows "5678".

What has happened is that the both definitions of "word1" exist in the
system, as separate chunks of code that happen to have the same name.
"word2" still calls the first one - the only one that existed when
"word2" was compiled (early binding). But the interactive interpreter
sees that most recent one, because the search for defined words starts
with later definitions and stops when it gets a match.

Recursion and Chaining 

This next topic is perhaps a bit too advanced for this stage of the
lesson series, but I'm including it anyway because I know that some
readers will wonder about it...

Okay, what happens if you try to use the word "xyz" inside the definition
of "xyz"? The question is especially interesting in light of the fact
that you can have multiple definitions with the same name. You might
reasonably want a new definition to "xyz" to call a previous version of
"xyz" and then extend its behavior. You might also reasonably want
recursion. And in fact, you can do either.

#pre
 [ dup 1 > [ dup 1- recurse * ] ifTrue ] is factorial
 5 factorial .
 120
#unpre

Don't worry about the words you don't yet know. Just notice that
"factorial" calls "factorial" recursively, which works because we used
<b>recurse</b> inside the definition.

Now let's look at the other possibility, in which we want a new
definition to call and extend an existing definition of the same name: 

#pre
 [ 111 . ] is init
 init
 111

 [ init 222 . ] is init
 init
 111 222
 
 [ 0 . init ] is init
 init
 0 111 222

Here we have created a word "init" that displays the number 111, then we
made a new word of the same name that calls the old one and also displays
"222", and finally we made a third one that first displays "0", then
calls the second one (which still calls the first one). It works because
the name of each successive redefinition is hidden until complete, so the
interpreter/compiler finds the previous one during the compilation of the
new one.

Clearly, you should use this redefinition thing sparingly, lest confusion
reign, but there are situations where this sort of thing can be extremely
useful. It's especially nice for initialization sequences where each
module can just add its own init code to whatever is already there.

The reason I'm explaining how all this works is because, unlike most
other languages, Toka gives the programmer explicit access to the same
machinery that the compiler uses. This, perhaps more than any other
feature, is what makes Toka so powerful with such a small memory
footprint. (LISP is similar in that respect.) Since the machinery is an
integral part of the proposition, you have to understand the basics of
how it works.

= Stack Comments, Reprised =

So far I have just been tossing out new definitions willy-nilly, without
any documentation. That is fine when you are just fooling around
interactively, experimenting. But, of course, when you are writing
"keepers", source code that you want to save in a file, you need some
documentation. The minimum documentation is a stack diagram. If I were to
save the previous recursive definition of factorial in a file, I would
probably write:

#pre
 [ ( n -- n! )
   dup 1 > [ dup 1- recurse * ] ifTrue
 ] is factorial
#unpre

The stack diagram "( n -- n! )" indicates that there is one argument and
one result. For this example, that would probably be enough, since
factorial is a well-known mathematical function and the name is pretty
clear. If the intent of the new word were not so obvious, I would have
added a line or two of commentary (beginning with "#!") before the
definition. 

<i>Thus endeth the lesson</i>} 1178672803


#--------------------------------------------------
# Lesson 5

page {Lesson 5} {Review 

In the previous lesson, we learned that: 
New words can be created with ": newname ...  ;" 
The interpreter has a "compile state" used for making new words 
New words are not "visible" until they are finished 
The interpreter finds the most recent definition of a given name 
Words can call themselves recursively 
A word can call another word of the same name, creating a "chain" 
[edit]
Introspection 

Today's lesson is about introspection - interactive exploration of the Forth system itself. Many Forth systems have some degree of introspection; the facilities in Open Firmware are fairly extensive. 
[edit]
Decompiler 

The decompiler "see" displays a pretty-printed representation of the source code for the target word. 
 ok see here
 : here
    dp @
 ;

In the example above, the target word was a system-defined colon definition. In addition to the colon definitions which we have already learned about, Forth has some other kinds of words which will learn about them later. The decompiler knows about those other kinds of words: 
 ok see dp
 224 user dp  value = -1210197548 
 ok see bl
 32 constant bl 
 ok see +
 code + 
 b7db1430     pop     ebx
 b7db1431     pop     eax
 b7db1432     add     eax,ebx
 b7db1434     push    eax
 b7db1435     jmp     edi

The example above shows a word "+" which is implemented in assembly language. A few words at the core of the system are like this, but most of the several thousand words are implemented as colon definitions. 

You can also use the disassembler for assembly language code that is not in the form of Forth code words. For example, if you have loaded a Linux kernel at the address 0x100000, you could inspect it with: 
 ok 100000 dis

You can decompile the entire Forth system, down to the very roots. So in some sense, Open Firmware has always been "open source", since the very first Open Firmware system included the full decompiler. (Some will no doubt quibble about this claim; in practice, for all the "free speech" talk, most people really want "free beer".) 
[edit]
Look-ahead Words 

Most Forth words take their arguments from the stack, but there are a few that get one or more string arguments by parsing ahead in the input stream. We have already seen some examples of this, notably comments and ":". "see" is another example. The amount of "look ahead" in such cases is typically fixed, not context-dependent. (You could write a context-dependent look-ahead word, but such usage is exceedingly rare in common Forth usage.) 

For most "look-ahead" words, there is a variant version with a slightly different name that takes its arguments from the stack instead of from the input stream. The look-ahead versions are convenient for interactive use, whereas the stack-based versions are convenient for use within other words. 
[edit]
Wordfinder 

How do you find the word you want among the thousands available? 
 ok sifting valid
         In vocabulary  forth 
 (b7dcfc60) bp-address-valid?    (b7dce2d4) state-valid   
 (b7dce248) %state-valid         (b7dbbd04) ?block-valid   

The "sifting" command parses a whitespace-delimited string from the input stream and searches for words whose name have it as a substring. 

You may see several lines like "In vocabulary forth", with other names in place of "forth". The system contains several "vocabularies" (lists of words). The "forth" vocabulary is by far the largest, containing all of the core Forth words. There are other vocabularies with words that implement special-purpose functions. There is a search order that controls which vocabularies the interpreter searches at any given time. A future lesson will describe vocabularies and search orders in more detail. 

Open Firmware "device tree nodes" are implemented as vocabularies with a special structure. "sifting" looks only in the ordinary vocabularies, but there is a similar word for looking in device tree nodes: 
 ok sift-devs show-b
         In device  /pci/nandflash@c
 (ff88db78) show-bbt
[edit]
Callfinder 

To find where a word is used, 
 ok ' save-image .calls
                   Called from save-image                at  b7dca444
                   Called from save-forth                at  b7dca4e8

The first item in the list of usages is often the word itself. That does not necessarily mean that the word is recursive. Rather, it is an artifact of the algorithm that the callfinder uses. So don't believe the list completely. The callfinder will find every compiled-in use of the word, but it will sometimes get spurious "hits" too. The callfinder will *not* find transient usages, i.e. references to the word that are stored in variables. 
[edit]
Execution Tokens and "'" 

The stack diagram of ".calls" is "( xt -- )". "xt" is the notation for "execution token", which is a numeric identifier that uniquely specifies a particular instance of a word. Recall that you can reuse the same word name several times, with the older instances remaining present in the system (possibly still called within other words). Each such instance has a distinct execution token. In many implementations, the execution token is the memory address of a data structure representing the word, but portable code must treat execution tokens as opaque identifiers. 

"'" (a single quote) is a standard word that parses a whitespace-delimited name from the input stream and pushes the execution token of the most recent definition of that name. Normally, when the Forth interpreter encounters a word, it executes it, but there are times when you want to refer to the word instead of executing it. That is what "'" is for. You can think of it as "quoting" the word. Note that "'" applies to already-defined Forth words, not to arbitrary text strings. If you try to apply "'" to a string that is not a defined word, you will get an error message. 

Referring back to the "sifting" example above, the number in parentheses before each word is its execution token. You can use this to get a handle on words whose names have been redefined. "(see)" is a variant of "see" whose argument is an execution token from the stack instead of a string from the input stream: 
 ok b7dce2d4 (see)

The number above comes from the "sifting valid" example; it happens to be the execution token of "state-valid" in the system I'm using right now. In general, that number probably won't work on your system. But you could say: 
 ok ' here (see)

"sifting <something>" then "<xt> (see)" (where <xt> is a number you type based on looking at the output of "sifting") is a good way to look at the definitions of superseded versions of words. 
[edit]
"'" inside definitions 

Inside a colon definition, "'" won't do what you probably expect. 
 ok : myword   ' save-image .calls  ;

You might expect your new word "myword" to be equivalent to interactively executing: 
 ok ' save-image .calls

but that is not what happens. What happens is that "'" parses the input stream when "myword" is executed, not when "myword" is compiled. 

Here is how to write what you probably meant: 
 ok : myword  ['] save-image .calls  ;

"[']" is a variant of "'" that does the look-ahead parsing during compilation. 

Yes, I realize this is confusing. Just use "'" outside colon definitions and "[']" inside, and the right thing will happen. 

Thus endeth the lesson
} 1178709393


#--------------------------------------------------
# Lesson 6

page {Lesson 6} {In the previous lesson, we learned how to: 
Examine words with "see" and "(see)" 
Disassemble machine code with "dis" 
Find words with "sifting" and "sift-devs" 
Find uses of a word with ".calls" 
Find execution tokens with "'" and "[']" 
[edit]
Data 

There are several ways to store and retrieve data values. 
[edit]
Variables 
 ok variable myvar

"variable" defines a new word (parsing the new word name from the input stream, as with ":") and allocates enough data space for a number (e.g. 32-bits). When you later execute the new word ("myvar" in this case), it pushes the address of that data area. The stack diagram for the new word is "( -- adr )". The initial contents of the data is undefined. 

You can put data into the variable with: 
 ok 12345 myvar !

"!" is pronunced "store". Its stack diagram is "( n adr -- )". 

To get the data back, use 
 ok myvar @ .
 12345
 ok 555 mvar !
 ok myvar @ .
 555

"@" is pronounced "fetch". Its stack diagram is "( adr -- n )". Note that, after the example above, the data value is on top of the stack. To display it, you would need to say "." afterwards (unless "showstack" mode is on). 

When you decompile a variable (e.g. "see myvar"), the decompiler may identify it as a "user" word. That is an implementation detail that is related to the fact that many Forth systems support multi-threading. A "user" variable is one that is allocated in the per-thread data area. 
[edit]
Other Memory Access Operators 

The size of the number that "variable", "@", and "!" use is the "natural" size for the implementation, similar to "int" in C. 

"@" and "!" are not limited to addresses returned by variables; they can be used with arbitrary memory addresses. However, for externally-defined data, it is usually a good idea to use memory access operators that explicitly specify the data size. 
 l@  ( adr -- l )    \ Fetch a 32-bit value
 l!  ( l adr -- )    \ Store a 32-bit value
 w@  ( adr -- w )    \ Fetch a 16-bit value
 <w@ ( adr -- w )    \ Fetch a 16-bit value, sign extending
 w!  ( w adr -- )    \ Store a 16-bit value
 c@  ( adr -- b )    \ Fetch a 8-bit value
 c!  ( b adr -- )    \ Store a 8-bit value

Don't use bare "@" and "!" for accessing memory-mapped I/O registers, because some implementations may perform "@" and "!" with multiple machine instructions in order to handle unaligned addresses. The explicit-sized operators listed above will usually work, but for ultimate portability when writing FCode device drivers, there are some other I/O access operators that make strong guarantees (byte ordering, atomicity, non-cached, etc). That is a topic for later. 
[edit]
Values 

"value" is an alternative to "variable" that is more convenient to use in many situations: 
 ok 4567 value myval
 ok myval .
 4567
 ok 98 to myval
 ok myval .
 98

As usual with "defining words" (words that create other words, like ":" and "variable"), "value" parses the name of the new word from the input stream. 

Unlike variables, values 
Are explicitly initialized when created (the inital value comes from the stack) 
Are "self fetching", i.e. the new word pushes the value instead of the address that contains the value. 
Must be preceded by "to" in order to set the value. 

"to" is not specific to values; it can also set the data for some other kinds of words we haven't learned yet. "to" is fairly "smart", and thus is a little slower than "!" (whose implementation is trivial). The speed difference is irrelevant in most cases. As compensation for "to myval" being a bit slower than "myvar !", "myval" is a bit faster, and slightly more space-efficient, than "myvar @". So for the common case where you retrieve the data more often than you set it, values are a good choice. Furthermore, code that uses values is a somewhat easier for humans to read. 
[edit]
Longer Data Structures 

Here is how to create a table with multiple data values: 
 ok hex
 ok create my-table  000 , 111 , 222 , aaa , bbb , fff ,
 ok my-table @ .
 0
 ok my-table 4 + @ .
 111
 ok my-table 2 na+ @ .
 222
 ok my-table 4 na+ @ .
 bbb

"create" is a defining word that makes a new word ("my-table" in this case) and marks the beginning of a data area that will be allocated by later words like ",". Later execution of the new word (e.g. "my-table") pushes the beginning address of that data area, so you can use memory access operators like "@" and "!' to read or write it. The stack diagram of the new word "my-table" is "( -- adr )", the same as a variable. 

Here are some operators that are useful after "create": 
 ,  ( n -- )    \ Allocate data space for a number and put n there
 c, ( b -- )    \ Allocate data space for a byte and put b there
 w, ( w -- )    \ Allocate data space for 16 bits and put w there
 l, ( w -- )    \ Allocate data space for 32 bits and put l there
 allot  ( n -- )  \ Allocate data space for n bytes (uninitialized)

The data space that is allocated by consecutive calls to these words is contiguous, so you can do arithmetic on addresses to get from one item to the next. However, that guarantee only lasts until you define the next word. 

In the "my-table 4 + @" example above, we assumed that numbers are 32-bits, using "4 +" to get from the table base address (as returned by "my-table") to the address of the second number. That's fine for interactive use on a known system, but for code you want to save, it's better to write something more portable, hence the use of "na+" in later lines. There are several such address arithmetic operators: 
 na+  ( adr n -- adr' )   \ Add n times the size of a number to adr
 ca+  ( adr n -- adr' )   \ Add n times the size of a byte to adr
 wa+  ( adr n -- adr' )   \ Add n times the size of a 16-bit word to adr
 la+  ( adr n -- adr' )   \ Add n times the size of a 32-bit longword to adr

On byte-addressed machines (nearly all machines these days), "ca+" is equivalent to just "+", so it is rarely used. "la+" is equivalent to "4 * +" (multiply n by 4 and add the result to adr), but is faster, more space-efficient, and more explicit, so "la+" is highly recommended. 

You can make arbitrary data structures after "create"; they are not limited to arrays of the same basic number size. To access the items, you can either do explicit address arithmetic on the table base address or define some named helper words to add the offsets for specific items. There is a "field" defining word to make that easier, a topic for later. 
[edit]
Constants 

Suppose you need a Forth word that returns (i.e. pushes on the stack) a single numeric value. You could do that with a colon definition, as in: 
 ok : mynum  12345  ;

However, constants are important enough that Forth has a special defining word for them: 
 ok 12345 constant mynum

Functionally, the two different definitions of "mynum" are equivalent, but the "constant" definition will execute slightly faster and occupy less space. (If you subsequently call "mynum" within another definition, the space occupied by the call is usually the same for either form; it it just the definition of "mynum" itself that is more compact in the "constant" case.) 

When you are writing code in a file for saving, it is a good idea to specify the number base explicitly, instead of assuming a particular value (e.g. hex or decimal) for the current number base. So in a file I would write: 
 d# 12345 constant mynum

or 
 h# 1a234f constant mynum

The only case where I intentionally break this rule is in a large table of numbers or in a large definition that is completely dominated by numbers (such as a list of register values). In those cases, I sometimes explicitly set the base at the top and list the numbers without prefixes, so the proliferation of prefixes doesn't obscure the code. 
[edit]
Efficiency of Constants 

Using a named constant in a colon definition is marginally faster than using a literal number, and the colon definition is smaller. Specifically, comparing 
 ok 1234 constant foo
 ok : add-foo  foo +  ;

to 
 ok : add-foo  1234 +  ;

The former definition of "add-foo" takes a little less space in the system, and executes marginally faster, than the latter definition. However, the space savings inside "add-foo" are more than made up for by the space used by the definition of the constant "foo". The break-even point for the space of a constant definition is about three later uses inside a colon definition. 

At some level this is a trivial detail, but it introduces an interesting point. In Open Firmware, the numbers 0 through 8 are actually defined as constants, thus saving a useful amount of space in the system image compared to the size if they were handled as literals in the ordinary way. 
 ok see 5
 5 constant 5
 ok see 1234
 1234 ?
} 1178709357


#--------------------------------------------------
# Lesson 7

page {Lesson 7} {Review 

In the previous lesson, we learned how to: 
Uses variables and values to store numbers 
Use "create" and "," to make named data structure instances 
Perform simple address arithmetic 
Use "constant" to make efficient symbolic names for constants 
[edit]
Control Structures 
[edit]
Conditionals 
 ok hex
 ok : hex-digit  ( n -- ascii )  \ Convert low nibble of n to ASCII hex
  ]    h# f and         ( low-nibble )
  ]    dup 9 <=  if     ( low-nibble )
  ]       h# 30 +       ( ascii )
  ]    else             ( low-nibble )
  ]       h# 37 +       ( ascii )
  ]    then             ( ascii )
  ] ;
 ok 6 hex-digit .       \ . displays the numerical value
 36
 ok 6 hex-digit emit    \ Emit displays the number as an ASCII character
 6
 ok f hex-digit .
 46
 ok f hex-digit emit
 F

This simple example illustrates quit a few points. First, observe that you can continue definitions across lines. When you are doing so interactively, the prompt changes from "ok" to "]" to remind you that you are in the middle of a definition. 

Also note the commenting style of listing the stack contents at the end of each line. This simple expedient is extremely helpful in making Forth code easy to write, debug, analyze, and maintain. 

Finally, let's focus on the conditional structure "if ... else ... then", the main topic of this lesson. 

These names are unfortunate, causing immediate confusion. The names should have been "if ... else ... endif", but for some reason, the name "then" was chosen as the end of the structure. 

The general usage is 
 <code_to_compute_a_flag>  if  <true_clause>  else  <false_clause>  then

"<code_to_compute_a_flag>" can be anything that leaves a number on the top of the stack. "<true_clause>" can be any sequence of Forth code; it is executed if the flag (the number on top of the stack when you get to "if") is nonzero. "<false_clause>" is executed if the flag is zero. 

You can think of "if" as a conditional branch to just after the "else" and "else" as an unconditional branch to just after the "then". In fact that is essentially how it is implemented. 

The "else <false_clause>" is optional; you can just write "if ... then". 
[edit]
Comparison Operators 

The "flag" value that "if" tests can be an ordinary number (0 is considered false, nonzero true) or a well-formed flag. A well-formed flag is either 0 (false) or -1 (true). In either case, it is just a number on the top of the stack. There are quite a few operators that perform comparisons, typically used to create flags for control structures. All of these operators return well-formed (0 or -1) flags. 
 =    ( n1 n2 -- flag )  \ True if n1 = n2
 <>   ( n1 n2 -- flag )  \ True if n1 != n2
 <    ( n1 n2 -- flag )  \ True if n1 < n2  (signed)
 u<   ( u1 u2 -- flag )  \ True if n1 < n2  (unsigned)
 >    ( n1 n2 -- flag )  \ True if n1 > n2  (signed)
 u>   ( u1 u2 -- flag )  \ True if n1 > n2  (unsigned)
 <=   ( n1 n2 -- flag )  \ True if n1 <= n2  (signed)
 u<=  ( u1 u2 -- flag )  \ True if n1 <= n2  (unsigned)
 >=   ( n1 n2 -- flag )  \ True if n1 >= n2  (signed)
 u>=  ( u1 u2 -- flag )  \ True if n1 >= n2  (unsigned)
 0=   ( n -- flag )      \ True if n = 0   (logical not, like '!' in C)
 0<>  ( n -- flag )      \ True if n != 0
 0<   ( n -- flag )      \ True if n < 0
 0>   ( n -- flag )      \ True if n > 0
 0<=  ( n -- flag )      \ True if n <= 0
 0>=  ( n -- flag )      \ True if n >= 0
 true   ( -- -1 )        \ Pushes true (-1)
 false  ( -- 0 )         \ Pushes false (0)
 between  ( n low high -- flag )  \ True if low <= n <= high
 within   ( n low high -- flag )  \ True if low <= n <  high

Let's break down the "if" line in the example above. It reads "dup 9 <= if". Before this line starts executing, the top of the stack is a number that is the low nibble of the argument value, i.e. a number from 0..f, as indicated by the stack comment at the end of the "h# f and" line. 
         ( low-nibble )
 dup     ( low-nibble low-nibble )
 9       ( low-nibble low-nibble 9 )
 <=      ( low-nibble flag )
 if      ( low-nibble )

The "dup" makes a copy of the number, because we will still need that number after we do the comparison. "9" pushes the number nine. "<=" pops two numbers from the stack (low-nibble and 9), performs the comparsion, and pushes a flag that represents the result. "if" pops the flag. If the flag was nonzero, the code between "if" and "else" is executed, otherwize the code between "else" and "then" is executed. In either case, low-nibble is on the stack ready for the addition. (The "+" could be moved out of the conditional, after the "then".) 
[edit]
Conditional Loops 

Conditional looping works in a similar fashion; a flag on the stack controls whether or not looping continues. There are several forms: 
 begin  <code>  again            \ Executes <code> forever
 begin  <code>  ( flag ) until   \ Executes until the flag is true
 begin  <code1> ( flag ) while  <code2>  repeat   \ See below

"begin <code> again" is a forever loop. Essentially, "again" is an unconditional branch back to just after "begin". "<code>" can be any sequence of Forth words. "begin <code> until" is an "exit at the end" loop. It executes <code>, which should leave a flag on the top of the stack. "until" pops that flag and if it is zero, "until" branches back to just after the "begin". 

"begin <code1> while <code2> repeat" is an "exit at the beginning" loop. "while" pops a flag from the stack (presumably left by <code1>). If the flag is nonzero, loop execution continues with <code2> and "repeat" branches back to just after the "begin". If the flag is zero, "while" branches to just after the "repeat". Normally <code1> does the conditional test and <code2> does the "work", but you can put anything you want in <code1> so long as it leaves a flag value on the stack when it is done. 

Note that the sense of the flag is different for "while" and "until". "while" loops while the flag is true, whereas "until" loops until the flag is true (i.e. while it is false). 

Here are some concrete examples: 
 ok  0  begin  dup .  1+  dup 5 =  until
 0 1 2 3 4

Note that in Open Firmware control structures can be used either interactively as shown above or inside colon definitions as shown in the "if" example. (By the way, there is a better way to do counting loops, as we will see soon.) 
 ok begin  5 .  key? until
 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 ...

That will keep displaying 5 until you type a key. "key? ( -- flag )" tests the input device to see if a character is available. "begin ... key? until" is a handy way to beat on hardware registers; just replace ... with code to do whatever you want. It will run until you stop it by typing a key. 
 ok  5  begin  dup  while  dup .  1-  repeat
 5 4 3 2 1
 ok  0  begin  dup  while  dup .  1-  repeat
 ok
[edit]
Do Loops 
 ok 7 2  do  9 .  loop
 9 9 9 9 9 
 ok 7 2  do  i .  loop
 2 3 4 5 6
 ok 7 2  do  i .  3 +loop
 2 5 

"( limit start ) do <code> loop" iterates over integers beginning with start (the top of the stack when "do" is first encountered) and ending when the index reaches limit (second on stack). Note that the loop stops when limit is reached, so the index value is never equal to limit inside the loop. 
 ok 5 0  do  i .  loop
 0 1 2 3 4

If "start" is 0 and "limit" is n, the body of the loop will execute n times. 

"i" pushes the loop index onto the stack. If you nest do-loops and need to "reach out" and get the index of the enclosing loop, that is "j", and then "k" for triply-nested loops. That is as far as it goes. 

"( n ) +loop" adds n to the loop index instead of 1. 

"do" always executes the body at least once, even if start and limit are the same. "?do" is like "do" except that is won't execute the body if start and limit are the same limit. 

To specify the loop boundaries as "( start length )" instead of "( limit start )", use "bounds" to do the conversion: 
 bounds  ( start length -- limit start )

Here is an example: 
 ok  10000 5  bounds  do  i .  loop
 10000 10001 10002 10003 10004 

You can run a loop backwards, with a negative increment value to "+loop". The stopping condition is somewhat surprising: 
 ok  1 5  do  i .  -1 +loop
 5 4 3 2 1

Why did it display 1, since up-counting loops don't execute when the index is equal to the limit value? The rule is this: The loop stops when the index crosses the boundary between limit-1 and limit. So on the way up, the last index value is less than limit, while on the way down, the last index is equal to limit. Takes a bit of getting used to, but the rule is precise, and there is really no way to do it better, considering that "+loop" cannot know in advance which way the loop is going (because the increment value can be computed at run time). 

You can terminate a do loop prematurely, before the limit has been reached, with "leave". 
 ok  1000000 0  do  i .  key?  if  leave  then   loop
 0 1 2 3 4 ...

That would count up to 1000000, stopping early if you type a key. 


[edit]
How Control Structures Work 

You might find it difficult to reconcile the behavior of control structures with what previous lessons have said about how the compiler works. In compilation state, the interpreter/compiler is supposed to simply add the behavior of each word to the new definition. So how do the various parts of control structures "hook up" with each other? For example, how does "if" find the target of its forward branch? 

The answer is that a few words are specially marked with an "immediate" bit. Those "immediate" words are not compiled directly, but instead are executed when encountered in compilation state. They can be thought of as parts of the compiler mechanism. The compiler mechanism is thus extensible, because you can create your own immediate words. 

Most of the control structure words are immediate. Consider the sequence "if ... then" inside a definition. Since "if" is immediate, the compiler doesn't compile it in the usual way, but instead executes it. When "if" executes, it uses compiler primitives to compile a conditional branch token into the current definition, followed by a dummy branch offset (since the true branch offset is not yet known). Then it pushes the address of that branch offset onto the stack, thus remembering it for later. "if" then returns to the compiler, which proceeds to compile the body of the control structure in the normal way. The compiler eventually gets to "then", which is also immediate, so it gets executed too. "then" gets the address of the dummy branch offset from the stack and fixes up the offset, since the branch distance is now known. 

Other control structure words work in similar fashion, executing during compilation to compile conditional or unconditional branches, resolving the offsets as they become known. All of the stack activity surrounding the branch resolution occurs during compilation. When the new definition is later execution, the only stack activity related to the conditional control structures is the popping of the flag value that controls which path is taken. 

There is an additional wrinkle with do loops. They have to manage the loop index and the limit value, neither of which is, in general, known at compile time. Do loops use the return stack (the auxiliary stack that holds subroutine return addresses) for storing loop control parameters. This is possible because do loops must be properly nested with respect to definitions, i.e. a do loops must finish in a controlled fashion before you can return from the word that contains it. 
[edit]
How Interpreted Control Structures Work 

As mentioned previously, in Open Firmware you can use control structures interactively, without compiling them inside a colon definition. How does that work, in light of the preceding description about how they are compiled? 

When a control structure starting word (e.g. "begin") is executed but the interpreter state is "interpretation" instead of "compilation", it calls a word that starts a temporary anonymous colon definition, and then everything works as before. When that control structure is completed, the ending word (e.g. "until") notices that, and calls a word that executes then discards the temporary definition. So "interpreted" control structures execute at full compiled speed. 

Note that in ANS Standard Forth, succh as gforth, control structures are only allowed inside of definitions, not at the interactive command line. 

Thus endeth the lesson
} 1178709442


#--------------------------------------------------
# Lesson 8

page {Lesson 8} {Review 

In the previous lesson, we learned: 
The conditional control structure "if ... [ else ... ] then" 
Various conditional looping structures like "begin ... until" 
The comparison operators 
"do ... loop" and its variations and wrinkles 
That the compiler has an extension mechanism 
How control structures are implemented using that mechanism 
[edit]
Strings 

As in C, strings are not a first-class data type in Forth. Forth has no support for automatic string allocation and garbage collection. This is in keeping with Forth's roots in real-time control on resource-limited systems. But as with C, you can do what you need to do, even if it isn't especially convenient. 
[edit]
Displaying Strings 
 ok : hello  ." Hello, world"  cr  ;
 ok hello
 Hello, world

Finally we have stated the Forth version of the canonical first program! ." (dot-quote) displays a string delimited by the next '"' . 

We didn't really have to make a definition: 
 ok ." Hello, world" cr
 Hello, world

Technically, in standard Forth, you are supposed to use .( instead of ." outside of a definition (for tedious reasons), as in: 
 ok .( Hello, world) cr
 Hello, world

but Open Firmware lets you use either form. 

"cr" sends a newline sequence to the output device. Contrast this to the C practice of embedding the newline as an escape sequence inside the string and letting the output device driver transform it into the appropriate sequence. Both approaches have advantages and disadvantages... 

Note that, as with everything else, ." is just a Forth word, and thus must be whitespace delimited. Its behavior is to parse a string delimited by " from the input stream and display it. ." is one of those "immediate" words that we talked about in the last lesson. When ." is encountered in compilation state, it executes immediately, parses out the string at compile time, then stores that string in the new definition as a literal, with some code to display it when the new definition later executes. 
[edit]
Literal Strings 

If you just want a literal string for use later, i.e. you don't want to display it, use " (quote) instead of ." (dot-quote). 
 ok : my-string  ( -- adr len )  " this is a test"  ;
 ok my-string type
 this is a test

The stack representation of a string is ( adr len ) - the address of the first character and the number of characters. Characters are just bytes. Only ASCII support is guaranteed, although Open Firmware typically has an ISO-Latin-1 font. The length includes just the characters in the string. There is no explicit notion in Forth of a null-terminated string like in C, so you could put binary data including 0 bytes in a Forth string. 

You can also use literal strings interactively: 
 ok " this is a test" type
 this is a test

In standard Forth, the string literal word is s" . Open Firmware implements s" for compatibility, but the Open Firmware word " is more convenient, and the Open Firmware source uses it exclusively in preference to s" . 
[edit]
Embedding Control Characters in Strings 

Open Firmware's " has a special escape syntax (not in standard Forth) that lets you put control characters and other binary data in strings. The syntax is carefully (and trickily) constructed so as not to conflict with standard usage. 
 " hello"(12 3a 88 7f)test"r"n"

That creates a string containing "hello" followed by the characters 0x12, 0x3a, 0x88, 07f, then "test", then carriage return, linefeed. 

Normally the second " would end the string, but in Open Firmware, a second " only ends the string if it is followed by whitespace. If non-whitespace follows the second " , subsititute characters are inserted in the string as follows: 
 After "         Replacement
 
 n               newline
 r               carriage return
 t               tab
 f               formfeed
 l               linefeed (same as newline)
 b               backspace
 !               bell
 ^x              control x (x is a printable character)
 (hh hh hh ...)  Sequence of bytes specified in hex
[edit]
String Storage 

Forth doesn't do automatic string allocation or garbage collection, so it's up to you to manage the storage. 

Literal strings that are compiled inside colon definitions live in the same memory space that contains the definitions, and should be treated as read-only. 

Literal strings entered in interpret state (outside of a definition) are stored in one of two temporary buffers dedicated to that purpose. The system alternates between the two buffers so you can have two interpreted strings active at the same time. 

You can allocate space for additional string storage as needed. 
[edit]
Some String Operators 

Inside a stack diagram, "$" is often used as a shorthand notation to refer to an "adr len" string. Thus in the stack diagram "( path$ -- )", the number of arguments is 2, the address and length of a string denoting a path. 
 type   ( adr len -- )                   Display string
 2dup   ( adr len -- adr len adr len )   Stack copy of string limits
 2drop  ( adr len -- )                   Discard string limits
 2over  ( $2 $1 -- $2 $1 $2 )            Stack copy of second string
 comp   ( adr1 adr2 len -- diff )        Compare memory buffers. 0 if equal.
 $=     ( $1 $2 -- flag )                Compare strings.  True if equal.
 evaluate  ( $ -- )                      Interpret string as Forth code

Note that "2dup", "2drop", and "2over", while quite useful for manipulating string limits on the stack, are not really limited to use with strings. They operate on arbitrary pairs of numbers and are used in many other contexts. 
[edit]
Counted Strings 

If you need to store a copy of a string in memory and are sure that the string is shorter than 256 bytes, you can use the space-efficient "counted string" format. In memory, a counted string consists of a length byte followed by n data bytes. 
 place  ( $ adr2 -- )           Save string at adr2 in counted form
 pack   ( $ adr2 -- adr2 )      Like place but returns adr2
 count  ( adr1 -- adr2 len2 )   Return adr,len of counted string
 $save  ( $ adr2 -- $2 )        Save $1 at adr2 counted form, returning
                                the addres and length of the copy
 $cat   ( $ adr2 -- )           Append $ to the counted string at adr2

For "count", adr2 is always adr1+1, and len2 is the value of the byte at adr1, as a direct consequence of the way that the counted string format is defined. 
[edit]
Memory Allocation for Strings 
 alloc-mem  ( len -- adr )      Allocate memory (useful for strings)
 free-mem  ( adr len -- )       Free previously-allocated memory

Alloc-mem and free-mem allocate anonymous memory from the heap. To create a named string buffer, use "buffer:". 
 ok d# 100 buffer: my-string
 ok " This is a test" my-string place
 ok my-string count type
 This is a test

The stack argument is the number of bytes to allocate for the buffer. "buffer:" is not limited to counted strings; it can allocate named buffers of arbitrary size. 
[edit]
String Parsing 
 sindex  ( $1 $2 -- n )
    Search for an occurrence of $1 inside $2.  If found, n is the offset
    within $2 where it was found.  If not found, n is -1.
 
 split-string       ( $1 delim -- tail$ head$ )
    Find the first occurrence of "delim" in $1.  If found, head$ is the
    portion of $1 up to but not including the delimiter and tail$ is the
    portion of $1 from the delimiter (inclusive) to the end.  If not
    found, head$ is $1 and tail$ is empty (i.e. its length is 0).
 
 left-parse-string  ( $1 delim -- head$ tail$ )
    Find the first occurrence of "delim" in $1.  If found, head$ is the
    portion of $1 up to but not including the delimiter and tail$ is the
    portion of $1 after the delimiter (not inclusive) to the end.  If not
    found, head$ is $1 and tail$ is empty (i.e. its length is 0).
      
 lex  ( $1 delim$ -- tail$ head$ delim true | $1 false )
    Find the first occurrence in $1 of any character in delim$ .  If found,
    head$ is the portion of $1 up to but not including the delimiter,
    tail$ is the portion of $1 after the delimiter (not inclusive) to the
    end, delim is the actual character found, and the top of the stack is
    true.  If not found, $1 is the original value of $1 and the top of
    the stack is false.

This is a sampling of some common general-purpose string operators. There are quite a few others. 

Thus endeth the lesson
} 1178709475


#--------------------------------------------------
# Libraries

page Libraries {Toka has an optional set of external libraries that allow significantly
more functionality. These are not included with a standard Toka
distribution and can be obtained at:

#pre
  http://code.google.com/p/toka-library
#unpre

Libraries can be loaded with <b>needs</b>. For example, to load the
<i>strings</i> library (if installed), do:

#pre
  needs strings
#unpre

A master library, <i>everything</i>, is provided to import all current
libraries. This makes it easy to access all provided functionality in any
project. To make use of this, use this at the start of a program:

#pre
  needs everything
#unpre

=== Library Documentation ===

Each library module contains some documentation at the start of its code.
A few of the more significant library modules are documented here for
your use.

* [StringsLibrary] 
* [TimeLibrary]
* [MathLibrary] 
* [SocketLibrary]
* [ShellLibrary]
* [FloatsLibrary]} 1178150659


#--------------------------------------------------
# License

page License {Toka is Copyright (c) 2007 Charles R. Childers


Permission is hereby granted, free of charge, to any person obtaining a copy 
of this software and associated documentation files (the "Software"), to deal 
in the Software without restriction, including without limitation the rights 
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell 
copies of the Software, and to permit persons to whom the Software is furnished 
to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in 
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
IN THE SOFTWARE.} 1175645279


#--------------------------------------------------
# Limitations

page Limitations {* Cell size is machine dependent, generally 32 bits (4 bytes) or 64 bits
  (8 bytes) in size. <b>cell-size</b> returns the actual size in bytes.
* Character size is machine and OS dependent.  Normally 8 bits (1 byte).
  <b>char-size</b> returns the actual size in bytes.
* Quotes can be up to 64 elements (values, primitives, embedded quotes,
  calls to other quotes, string pointers, etc) in length.
* The data stack can hold up to 100 cells.
* The return stack can hold up to 1024 cells.} 1178430367


#--------------------------------------------------
# Loops

page Loops {Toka provides a limited collection of primitives for building various
types of simple loops.

The most basic form is <b>iterate</b>, which takes the following form:

#pre
  number-of-iterations quote  iterate
#unpre

<b>iterate</b> will invoke <i>quote</i> the specified number of times.
With <b>iterate</b>, the count goes down from N to 1, with 1 being the
last cycle of the loop. To count up from 1 to N instead, use
<b>+iterate</b>. Other than this, both of these words take the same form.
Some examples:

#pre
  10 [ i . ] iterate
  10 [ i . ] +iterate
#unpre

Note the use of <b>i</b>, the loop index. When looping via <b>iterate</b>
and <b>+iterate</b>, the loop index is set to the current cycle number.
<i>Other types of loops do not set the loop index.</i> 

The other type of loop is a <b>whileTrue</b> or <b>whileFalse</b> loop.
The normal form:

#pre
  quote whileTrue
  quote whileFalse
#unpre

Each time <i>quote</i> is invoked, a value of <b>TRUE</b> or <b>FALSE</b>
should be left on the stack. The loop primitives will consume this, and
either repeat the loop or end the loop until the condition is not met.
<b>whileTrue</b> continues execution if the returned value is <b>TRUE</b>;
<b>whileFalse</b> continues if the returned value is <b>FALSE</b>.

Some examples:

#pre
  1 [ dup . 1 + dup 101 < ] whileTrue
  101 [ dup . 1 - dup 1 < ] whileFalse
#unpre} 1177019422


#--------------------------------------------------
# math.c

page math.c {= Use =

Basic math operations on the stack.

= Functions Provided =

#pre
add()
Add TOS to NOS

subtract()
Subtract TOS from NOS

multiply()
Multiply TOS by NOS

divmod()
Divide and return the result, including remainder
#unpre

= Primitives Provided =

#pre
+
-
*
/mod
#unpre} 1175294665


#--------------------------------------------------
# MathLibrary

page MathLibrary {This library extends the core math functionality of Toka in minor ways. 

The provided API follows:

#pre
     abs
     ( n-n )
     Returns the absolute value of 'n'

     random
     ( -n )
     Returns a random number

     srandom
     ( s-x )
     Set a new seed for the random number generator

     ^
     ( xy-z )
     Returns x^y power

     sqrt
     ( x-y )
     Returns the square root of x

     sqrt-closer
     Used internally by sqrt
#unpre} 1177901677


#--------------------------------------------------
# MathOperations

page MathOperations {Toka provides a very basic set of math functionality, sufficient for many
purposes. The functions are:

#pre
  +        ( ab-c )    Add TOS and NOS
  -        ( ab-c )    Subtract TOS from NOS
  *        ( ab-c )    Multiply TOS by NOS
  /mod     ( ab-cd )   Divide and get remainder
#unpre

In addition, the standard bootstrap adds some additional operations:

#pre
  1+       ( x-y )     Increase value on stack by 1
  1-       ( x-y )     Decrease value on stack by 1
  negate   ( x-y )     Invert the sign of TOS
  /        ( xy-z )    Divide two numbers
  mod      ( xy-z )    Divide two numbers and get remainder
  not      ( x-y )     Invert the value 'x'
  */       ( abc-d )   (a*b)/c
#unpre} 1177020107


#--------------------------------------------------
# New Pages

page {New Pages} {To create a new page,

* Add a link to it in this page (or on any other page where the link would
  be more appropriate):
** Press the "Edit" button.
** Go to the bottom of the page (or anywhere, really).
** Type the page's name in square brackets, &lb;Like This&rb;.
** Press the "Done" button.
* Click on the link.
* On the Status Line, down at the bottom of the window, Notebook will ask
  if you want to create the page.  Type "yes" or "y", and press Enter.

<h>New Pages</h>

* [Tour]
* [Sandbox]} 1102291321


#--------------------------------------------------
# parser

page parser {Toka's parser is fairly simple. It only handles input coming from a
<i>file stream</i> (which includes <i>stdin</i>). Input sources are
implemented as a stack.

At the bottom is the <i>stdin</i> file. Generally on startup, the
<i>bootstrap.toka</i>. A script would be at the third position, and any
files that includes get added above it.

The parser will read from the top file until either <b>end.</b> or an EOF
(end of file) is detected. At this point, it closes the file and drops to
the next one on the stack.

Internally, the fundamental function for parsing is <b>get_token()</b>.
This accepts two arguments, a pointer to a buffer to place the resulting
string, and a delimiter character. Parsing ends when the delimiter
character is encountered. <b>get_token()</b> also leaves a pointer to the
resulting token on the stack. A Toka-level wrapper, <b>parse()</b>, makes
use of <b>get_token()</b>.

When parsing, a number of <i>escape sequences</i> are recognized. These
are listed below:

#pre
  \n
  Embed a carriage return (ASCII 10) into the token
 
  \r
  Embed a line feed (ASCII 13) into the token

  \^
  Embed ASCII 27 into the token. Useful with VT100/ANSI terminal
  escape sequences

  \\
  Embed a \ character into the token

  \"
  Embed a quote into the token
#unpre

Processing of escape sequences can be enabled or disabled by turning the
<b>escape-sequences</b> variable <b>on</b> or <b>off</b>. For example:

#pre
  escape-sequences off
  " \\ hello \\" type cr
  escape-sequences on
  " \\ hello \\" type cr
#unpre


=== Tips ===
* Tokens have a maximum size of 4096 characters
* If the delimiter = 10, <b>get_token()</b> will also break on
  encountering ASCII 13.
* If the delimiter = 32, <b>get_token()</b> will also break on
  encountering ASCII 10 or ASCII 13.} 1177990380


#--------------------------------------------------
# parser.c

page parser.c {= Use =

Implement the [parser].

= Functions Provided =

#pre
Variables:
  FILE *input[]
  Current file stream to parse from. Setup as
  an array of 8 inputs.

  long isp
  Pointer to the most recent input source in the array

  long base
  Holds the current numeric base

  long parser
  When ON (TRUE), system parsing words will parse. When
  OFF (FALSE), they will take a string from the stack.

to_number()
Attempt to convert a string (on TOS) to a number.
This accepts a format of:
  [-]number
If successful, it leaves the number and a flag of
-1 on the stack. Otherwise, it leaves the original
string, and a flag of 0.

parse()
Parse the input buffer until the character passed
on TOS is found, or until the end of the line is
encountered. Return a pointer to the resulting
string on the stack.

get_token(char *s, long delim)
Return a string (in "s") up to the specified 
delimiter. This also puts the resulting string 
on the stack.

long include_file(char *s)
Attempt to open a file ("s") and add it to the
top of the input stack.

include()
Take a filename off the stack, attempt to open
it and add it to the input stream if successful.

needs()
Take a filename off the stack. Attempt to open it
from the library, and add it to the input stream 
if successful.

force_eof()
Remove the current file from the input stack. This
can be used to abort an include.
#unpre

= Primitives Provided =

#pre
>number
parser
parse
include
needs
end.
#unpre} 1178016664


#--------------------------------------------------
# Ports

page Ports {This page lists the supported platforms and includes notes on building
for specific targets.

#---
Quick Summary:

* x86
** Linux
** Net, Free, Open, and DragonFly BSD
** OpenSolaris
** BeOS
** Cygwin
* ARM
** OpenBSD
** NetBSD
* MIPS
** NetBSD
** Linux
* Itanium (IA64)
** Linux

#---
= Linux =

* x86
* x86-64
* MIPS
* Itanium (IA64)

Toka has been built and tested on Debian and SuSE, using
GCC versions 2.95, 3.0, and 4.1

#---
= BSD =

=== OpenBSD ===
* x86
* ARM (cats)

=== FreeBSD 4.x - 6.x ===
* x86

=== NetBSD 3 ===
* x86
* MIPS (pmax)
* ARM (cats)

=== DragonFly BSD ===
* x86

#---
= BeOS =
* x86
* FFI requires libdl.so (not standard part of BeOS)
** http://bebits.com/app/2917
* You <i>may</i> need a newer GCC
** http://bebits.com/app/4011
* <i>make CFLAGS=-I/beos/develop/headers</i>

#---
= Cygwin =
* x86
* Tested under Windows XP and Vista
* FFI may be buggy

#---
= OpenSolaris =
* x86
* Tested under Nexenta} 1178435650


#--------------------------------------------------
# Quotes

page Quotes {With the functions described above, many small programs can be written.
Toka has much more functionality, but before proceeding further, we need
to take a look at how to create new functions (called <i>quotes</i>).

In Toka, a <i>quote</i> is the basic building block. At the simplest
level, they are anonymous blocks of code and data. Quotes are created by
encolsing the code and/or data in brackets:

#pre
  [ ]
#unpre

The above will create an empty quote and leave a pointer to it on the
stack. You can attach a name to this pointer with <b>is</b>:

#pre
  [ ] is empty-quote
#unpre

Names can include any characters, other than space, tab, cr, or lf (enter
key). (<i>There are other forms of <b>is</b>, but this is the most common
one; the others are discussed [elsewhere|WordClasses]</i>).} 1177465671


#--------------------------------------------------
# quotes.c

page quotes.c {= Use =

Build, operate on quotes.

= Functions Provided =

#pre
Variables:
  QUOTE quotes[8]
  Holds details about the compiler state, heap,
  etc for quotes during compilation.

  long qdepth
  Tracks how deeply the quotes are nested

  long quote_counter
  Tracks the current loop index

  Inst top
  Holds a pointer to the root quote

begin_quote()
Create a new quote. This allocates space for it,
and sets the compiler flag. A pointer to the
quote's start is pushed to the stack.

end_quote()
Terminate the previously opened quote and perform
data_class() semantics.

invoke()
Call a quote (passed on TOS)

iterate()
Repeat execution of a quote (passed on TOS), NOS
number of times.

alt_iterate()
Repeat execution of a quote (passed on TOS), NOS
number of times.

truefalse()
Takes three items (true-xt, false-xt, and a flag)
from the stack. Stack should be passed in as:
  flag true false 
It will execute true if the flag is true, false
otherwise.

recurse()
Compiles a call to the top-level quote. As a
trivial example:
  [ dup 1 > [ dup 1 - recurse swap 2 - recurse + ] ifTrue ] is fib

qlit()
Push the value in the following memory location
to the stack. This is used instead of lit() so
that the decompiler (and eventually debugger) can
reliably identify nested quotes as opposed to 
regular literals.

quote_index()
Return the current loop index (counter)

quote_while_true()
Return execution of a quote until the quote
returns FALSE.

quote_while_false()
Return execution of a quote until the quote
returns TRUE.
#unpre

= Primitives Provided =

#pre
[
]
recurse
i
whileTrue
whileFalse
invoke
iterate
+iterate
ifTrueFalse
#unpre} 1177812770


#--------------------------------------------------
# Recent Changes

page {Recent Changes} {[@recentChanges@]} 1026585675


#--------------------------------------------------
# Sandbox

page Sandbox {This is place to experiment with Notebook's way of marking up text.
Edit this page to see how you type things; then save it to see what it looks
like when you're browsing.

= You Can Have Section Headers =

*	You can have bulleted lists.
*	You can type <b>bold</b>, <i>italic</i>, and <m>monospace</m> text,
	or any combination.
*   You can have <h>inline header text</h>.
*	You can have <s>very small</s> text.
*   You can <x>strike things out</x>.

:	You can simply indent a paragraph without adding a bullet.

Paragraphs end with the first blank line, bullet item, or indented line.
No matter how many lines long a paragraph is, Notebook will wrap it for
display so that it looks nice.

 If you leave a space character at the beginning of a paragraph, the whole
 paragraph is "Preformatted".  That means that it's displayed in a monospace
 font, exactly as is.  It's conventional to put whitespace at the beginning of
 every line of a preformatted paragraph, but that's not necessary.

Preformatted text is useful for typing in tables and things like that.} 1113419698


#--------------------------------------------------
# Scripts

page Scripts {Toka can be used to write scripts. Start your code with the following:

#pre
  #! /usr/bin/toka
#unpre

And set the permissions to executable (<i>+x</i>), and you can run your
code directly at the command line (assuming that Toka is
[installed|installation]).

To make the most of your scripts, you will probably want to handle
command line arguments. Toka allows for this using the following words:

#pre
  #args        ( -n )   Returns the number of command line arguments
  arglist      ( -a )   An array containing the arguments
  get-element  ( ia-n ) Return a pointer to an element in the array
#unpre

Toka accepts a command line like the following:

#pre
  toka <script> <arg0> <arg1> ... <argN>
#unpre

If no arguments are given to Toka, <i>excluding than the optional script
filename</i>, <b>#args</b> will be set to <i>0</i>. In any other case,
<b>#args</b> will contain the number of arguments <i>following</i> the
script name. For example, in the following example, <b>#args</b> will
return <i>3</i>:

#pre
  toka foo.toka apple banana carrot
#unpre

The breakdown in the <b>arglist</b> will then be as follows:

* Element 0 is the name of the script, in this case <i>foo.toka</i>
* Element 1 is <i>apple</i>
* Element 2 is <i>banana</i>
* Element 3 is <i>carrot</i>

You can iterate over the arguments to process them. For instance, if we
wanted to display each of the script arguments, we could do:

#pre
  #args [ i arglist get-element type cr ] +iterate
#unpre} 1177553596


#--------------------------------------------------
# Search

page Search {[@searchIndex@]} 1175217539


#--------------------------------------------------
# ShellLibrary

page ShellLibrary {This library provides the fundamental support for calling external files
and doing actions normally done at the shell.

The provided API follows:

#pre
  remove
  ( $-n )
  Delete file '$'

  system
  ( $-n )
  Run string '$' as a shell command
#unpre} 1177901415


#--------------------------------------------------
# SocketLibrary

page SocketLibrary {The socket library is a <i>hybrid library</i>. It provides both a C
library module and a set of Toka bindings. The functionality is dependent
on both.

The provided API is as follows:

#pre
  pBind
  ( n-x )
  Bind to a specific port

  pConnect
  ( $n-s )
  Connect to host (string '$') at port 'n'. Returns a socket.

  pAccept
  ( n-x )
  Accept a new connection upon a socket.  Return the new client.

  pRead
  ( sbl-n )
  Attempt to read 'l' chars from socket 's' into buffer 'b'. Returns
  the number of bytes read.

  pWrite
  ( sbl-n )
  Attempt to write 'l' bytes from buffer 'b' to socket 's'. Returns
    the number of bytes written.

  pClose
  ( s-x )
  Attempt to close socket 's'.
#unpre

This API, while minimalistic, is sufficient to allow development of both
client and server applications. It has been used in conjunction with the
[StringsLibrary] and the [ShellLibrary] to implement a working HTTP
server.} 1177901287


#--------------------------------------------------
# Stack Comments

page {Stack Comments} {Stack comments provide a way to specify the action of a quote as it
relates to the stack. It's normally a good idea to keep a list of words
with their description and stack comments on hand if they are not part of
the source.

A typical stack comment will resemble the following:

#pre
  ( abc-d )
#unpre

The dash shows the before/after split. In the example above, the quote
takes three elements from the stack (a, b, and c) and leaves a new one
(d). 

Words that parse use <i>"</i> as a symbol to denote this. For example:

#pre
  ( a"-b )
#unpre

This is a stack comment for a word that takes a string (a), parses the
input until a specified symbol is encountered, and returns a new string
(b).

The exact meaning of the symbols is up to you. Generally in a
description, you can explain them better, but the stack comment form is
just a general overview.

<i>When you are learning Toka, it may be helpful to write out stack
comments for each step in a quote. This can help you keep track of the
stack and become more comfortable using it.</i>} 1177716268


#--------------------------------------------------
# stack.c

page stack.c {= Use =

Implements the basic stack operations. This is intentionally kept
minimal, though additional primitives can be added to improve overall
performance.

= Functions Provided =

#pre
stack_dup()
Duplicate the TOS

stack_drop()
Drop the TOS

stack_swap()
Exchange TOS and NOS

stack_to_r()
Push TOS to return stack, DROP TOS

stack_from_r()
Pop TORS to the data stack

stack_depth()
Return the number of items on the stack
#unpre

= Primitives Provided =

#pre
dup
drop
swap
>r
r>
depth
#unpre} 1176258218


#--------------------------------------------------
# strings

page strings {Strings are sequences of characters. Specifically a string is any
sequence of ASCII characters (each character can have a length identical
to <b>char-size</b>), and ending with the literal value 0.

Strings are created by parsing, or can be manually constructed as an
array. For example the following two are functionally identical:

#pre
  " hello" is-data hello
  hello type cr

  5 chars is-array hello
  char: h 0 hello put-char-element
  char: e 1 hello put-char-element
  char: l 2 hello put-char-element
  char: l 3 hello put-char-element
  char: o 4 hello put-char-element
        0 5 hello put-char-element
  hello type cr
#unpre

Since all strings are arrays, you can also manipulate individual elements
in a string:

#pre
  " hello" is-data hello
  hello type cr

  #! Now change the lowercase 'h' to uppercase.
  char: H 0 hello put-char-element
  hello type cr
#unpre

=== Tips ===

* <b>char-size</b> is normally equal to <i>1</i>, corresponding to one
  byte.
* It is possible (though not likely) to have a <b>char-size</b> larger
  than one byte.
* Use <b>c@</b> and <b>c!</b> when manipulating <b>char-size</b> elements.
* Do not use <b>@</b> and <b>!</b> (which are for <b>cell-size</b> elements).} 1177537581


#--------------------------------------------------
# StringsLibrary

page StringsLibrary {Toka provides a [loose abstraction|types] for strings. The strings
library is an attempt to significantly expand on that abstraction and
allow for many common actions to be done quickly and easily.

#pre
 Provides (from libc):
   strcpy   strncpy   strcat   strncat   strcmp   strncmp
   strchr   strstr    strlen   strrchr   strtok

 Provides:
   Data:    $[cr]     $[lf]
   Words:
            grow-string
            ( an-b )  
            Allocate a new string 'n' chars longer than the original
            'a' and copy the original string to it. Returns a pointer
            to the new string ('b').

            append-string
            ( ab-c )
            Combine strings 'a' and 'b' into a new string 'c'. This
            allocates the necessary space for the new string
            automatically.

            clone-string
            ( a-b )
            Create a new string ('b') identical to string 'a'. Space
            is allocated automatically.

            string-find-token
            ( ac-b )
            Search for character 'c' in string 'a'. Returns a new
            string containing everything up to, but not including
            'c'.

            string-find-substring
            ( ab-c )
            Search for string 'b' in string 'a'. Return a new string
            'c' starting with string 'b' and containing the rest of
            string 'a'.

            string-find-char
            ( ac-b )
            Search string 'a' for character 'c'. Return a new string
            'b' that starts with character 'c'.

            after-"
            ( a"-b )
            A parsing word. Parse ahead until " is encountered, then
            append string 'a' to it. Returns a new string 'b'.

            +lf
            ( a-b )
            Append a linefeed (ascii 13) to a string. Returns a new
            string.

            +cr
            ( a-b )
            Append a carriage return (ascii 10) to a string. Returns
            a new string.
#unpre} 1177901521


#--------------------------------------------------
# threading model

page {threading model} {Toka relies on <i>call threading</i>. This is an implementation technique
in which a list of addresses is compiled. Each of these is then called in
sequence. The model is similar to <i>direct threading</i> in the Forth
world.

There is one special address which marks the end of a threaded sequence.
This address is <b>0</b>.

As an example of this, consider the following quote:

#pre
 [ a b c 1 2 + . ]
#unpre

This is compiled into a list of addresses:

#pre
 a, b, c, lit, 1, lit 2, +, ., 0
#unpre

Note the special form for numbers. The [lit()|vm.c] function pushes the value in
the following cell to the stack.

When this quote is invoked, <i>a</i> will be called. After it finishes
executing, <i>b</i> will be called, and so on until <i>0</i> is
encountered. At that point, the [vm_run()|vm.c] function exits.} 1176257425


#--------------------------------------------------
# TimeLibrary

page TimeLibrary {This library allows obtaining the system time, timing functions, and
similar activities.

#pre
   Data:
     time_t
     
   Words:
     time
     difftime
     ctime
     .time
     :time
#unpre

#---

=== Examples ===

#pre
  needs time
  time_t today
  today time drop
  today ctime type
#unpre

#pre
  needs time
  [ dup 1 > [ dup 1 - recurse swap 2 - recurse + ] [ ] ifTrueFalse ] is fib
  [ 35 fib . cr ] :time
#unpre} 1177901642


#--------------------------------------------------
# toka.c

page toka.c {= Use =

Setup and call the interpreter.

= Functions Provided =

#pre
main()
The main entry point into Toka. Sets up the
dictionary and calls interpret().
#unpre

= Primitives Provided =

<i>None</i>} 1175294848


#--------------------------------------------------
# TokaDoc

page TokaDoc {= Introduction =

To help keep an up-to-date list of C functions and their Toka
equivilents, the TokaDoc scripts were developed. These seach C sources
for specially formatted comments and extract them into various files.
These files can be updated when [building].

= Supporting TokaDoc =

At the start of each C file, have a comment header like this:

#pre
 /*
  *|F|
  *|F| FILE: filename
  *|F|
  */
#unpre

Before any global variables, have a comment block like this:

#pre
/*
 *|F| Variables:
 *|F|   GCITEM gc_list[128]
 *|F|   Holds the list of items marked as garbage.
 *|F|
 */
#unpre

Before each function have a comment block like this:

#pre
 /*
  *|F| <return type> functioname(<arguments>)
  *|F| description of the function
  *|F|
  */
#unpre

And for any functions having a Toka equivilent, have a block like:

#pre
 /*
  *|G| wordname    stack-effect    description
  */
#unpre

Please try to keep columns lined up as much as possible for Toka wordlist comments.} 1175313140


#--------------------------------------------------
# Tutorial

page Tutorial {This is a series of lessons on the Toka programming language. It's based
directly on the tutorials for Forth and Open Firmware that were written
by Mitch Bradley for the OLPC project.

The original lessons can be found at http://wiki.laptop.org/go/Forth_Lessons

I have made as few changes as possible. I truely hope this proves
beneficial to all those who may wish to learn to use Toka.} 1178673241


#--------------------------------------------------
# Types

page Types {Toka has one data type, called the <i>cell</i>. This is a machine
dependent sized memory area that can hold a single number or pointer. On
32-bit systems, cells are 4 bytes in length, and on 64-bit systems, they
take 8 bytes. A constant, <b>cell-size</b>, returns the exact length
provided by Toka on your system.

Cells can hold numbers, pointers to allocated memory, and pointers to
quotes. When Toka encounters a number or a pointer, it is placed on the
stack. For more permanent storage, you can store cell values into memory
locations for later use. 

This is where a number of abstractions arise. Memory allocated for
storage of values is called [variables]. Memory allocated for sequences
of values are called [arrays]. And a special class of array is used for
sequences of characters. These are called [strings].

In all of these, when you reference them, a <i>pointer</i> is left on the
stack. Pointers are simply numbers corresponding to an actual memory
address. <i>It is up to you to know what abstract data type a pointer
represents</i>.

When dealing with variables, you can use <b>@</b> (fetch) and <b>!</b>
(store) to set and obtain the values stored in them. If you need to fetch
or store single characters (as may arise when manipulating strings), you
can use <b>c@</b> and <b>c!</b> instead.

Arrays have an entire abstracted set of words for dealing with them. It's
well worth learning to use these, as they are portable, and make
accessing and setting individual elements in an array trivial.

=== Tips ===

You are strongly encouraged to use <b>cell-size</b> and <b>char-size</b>
instead of hard coding the sizes for data. This helps ensure readability
and portability.} 1177462962


#--------------------------------------------------
# User Code

page {User Code} {Use this page to extend Notebook using the 
[@helpbtn "the Tcl language"@].  Commands you add here can be used as
[@helpbtn "Magic Button"@]s and [@helpbtn "Embedded Macro"@]s.

Note that you can intersperse normal prose in between blocks of Tcl code.

= User Menu =

The [@helpbtn "User Menu"@] pops up when you right-click or control-click 
on a page in the [@helpbtn "Page Browser"@].  You can customize it however you like.

#Tcl
usermenu {
    Back back-page
    Home {goto-page Home}
}
#unTcl

= Edit Menu =

The [@helpbtn "Edit Menu"@] pops up when you right-click or control-click 
on a page in the [@helpbtn "Page Editor"@].  You can customize it however you like.

#Tcl
editmenu {
    Undo             undo-change
    Redo             redo-change
    separator {}
    Cut              cut-string
    Copy             copy-string
    Paste            paste-string
    "Insert Page..." insert-page
}
#unTcl

= Example =

The following [@helpbtn "embedded macro"@] used to be used by the
[Tour] to create a [@helpbtn "magic button"@] that said 
"Click here to continue..." and took you to the next page in the tour
when you clicked it.  It's no longer needed, because now you can write
such links directly, like this:

  [Click here to continue...|Tour 2]

Still, it's a nice example of how to write a macro that creates a button.

#Tcl
proc clickToContinue {name} {
	return "\[%Click here to continue...|goto-page [list $name]%\]"
}
#unTcl} 1113420734


#--------------------------------------------------
# UsingTheStack

page UsingTheStack {he language makes use of a stack to pass data between functions (called
<i>quotes</i> in toka). Imagine a stack of blocks with numbers on them.
You can add or remove numbers from the top of the stack. You can also
rearrange the order of the numbers.

The stack is initially empty. Let's start by putting some numbers on the
stack. Type in:

#pre
  23 7 9182
#unpre

Excellent! Now print the number on top of the stack using <b>.</b>, which
is pronounced "dot". This is a hard word to write about in a manual
because it is just a single period.

Enter:

#pre
  .
#unpre

You should see the last number you entered, 9182, printed. Each time
<b>.</b> is used, the top element on the stack is lost. If you want to
see what is on the stack, you can use <b>:stack</b>. Try this:

#pre
  :stack
#unpre

You should see:

#pre
  <2> 23 7
#unpre

The number on the left, enclosed in brackets, is the number of items on
the stack. The number to the far right is the top of the stack, or
<i>TOS</i>. It should be mentioned that <b>:stack</b> leaves the stack
unchanged.

Since Toka uses the stack to hold data being operated on, and it uses the
stack to pass data between quotes, it is very important to practice using
it. Quotes generally take what they need off of the stack, and put their
results back on it. To help understand exactly what each quote consumes
and leaves, we use <i>stack diagrams</i>. As an example:


#pre
  . ( x- )
#unpre

That is to say, <b>.</b> takes one word off the stack (the 'x') and puts
nothing on the stack. In other words, it consumes the TOS.

In the examples that follow, you do not need to type in the comments.
When you are programming, of course, liberal use of comments and stack
diagrams may make your code more readable and maintainable.

Between examples, you may wish to clear the stack. If you enter
<b>reset</b>, the stack will be cleared. Since the stack is central to
Toka, it is important to be able to alter it easily. Let's look at some
more functions that manipulate the stack. Enter:

#pre
  reset
  777 dup :stack
#unpre

You will notice that there are two copies of 777 on the stack. The quote
<b>dup</b> duplicates TOS. This is useful when you want to use the TOS
and still have a copy. The stack diagram for <b>dup</b> would be:

#pre
  dup ( x-xx )
#unpre

Another useful quote is <b>swap</b>. Enter:

#pre
  reset
  23 7 :stack
  swap :stack
#unpre

The stack should look like:

#pre
  <2> 7 23
#unpre

The stack diagram for <b>swap</b> would be:

#pre
  swap ( xy-yx )
#unpre

Now enter:

#pre
  over :stack
#unpre

You should see:

#pre
  <3> 7 23 7
#unpre

<b>over</b> causes a copy of the second item on the stack to leapfrog
over the first. Its stack diagram would be:

#pre
  over ( xy-xyx )
#unpre

Here is another commonly used function:

#pre
  drop ( x- )
#unpre

Can you guess what we will see if we enter:

#pre
  drop :stack
#unpre

Another handy function for manipulating the stack is <b>rot</b> (short
for rotate). Enter:

#pre
  11 22 33 44 :stack
  rot :stack
#unpre

The stack diagram for <b>rot</b> is, therefore:

#pre
  rot ( xyz-yzx )
#unpre

You have now learned the more important stack manipulation words. These
will be present in almost every non-trivial Toka program. I will say that
if you see heavy use of these words in your code, you may want to examine
and reorganize (<i>refactor</i>) your code. Use of variables and arrays
(which we will discuss later) can also help clean things up.

Here are stack diagrams for some other useful stack manipulation
functions. Try experimenting with them by putting numbers on the stack
and calling them to get a feel for what they do. Again, the text in
parentheses is just a comment and need not be entered.

#pre
  2drop ( xyz--x )
  2dup ( xy-xyxy )
  nip ( xyz-xz )
  tuck ( xy-yxy )
#unpre} 1177452284


#--------------------------------------------------
# Variables

page Variables {To hold data for longer periods of time than is practical with the stack,
variables can be used. Variables are pointers to memory locations large
enough to hold a number. There are two primary ways to create variables:

#pre
  variable foo
  variable bar
  variable baz
#unpre

The above would create three new variables, named <b>foo</b>, <b>bar</b>,
and <b>baz</b>. When creating multiple variables, it is more readable to
use <b>variable|</b> though:

#pre
  variable| foo bar baz |
#unpre

You can use <b>@</b> (fetch) and <b>!</b> (store) to alter the contents
of a variable:

#pre
  variable foo
  100 foo !
  foo @ .
#unpre

For reading/writing character-sized values, <b>c@</b> and <b>c!</b> are
also provided. A full list of functions for working with variables follows:

#pre
  variable ( "- )      Parse ahead and create a named entry
                       corresponding to a memory location
  variable| ( |- )     Parse and create variables until | 
                       is encountered.
  @        ( a-n )     Fetch the value from variable 'a'
  !        ( na- )     Store 'n' to variable 'a'
  c@       ( a-n )     Fetch a byte from variable 'a'
  c!       ( na- )     Store byte 'n' to variable 'a'
#unpre} 1177020319


#--------------------------------------------------
# vm.c

page vm.c {= Use =

Implements the heart of the virtual machine.

= Functions Provided =

#pre
Variables:
  Inst *heap
  Pointer into the current heap

  Inst *ip
  The instruction pointer

  long stack[100], rstack[100]
  The data and return stacks

  long sp, rsp
  The stack pointers

vm_run(Inst)
Run through a list of instructions
Side effects:
  modifes *ip

vm_stack_check()
Check for over/underflow and reset if detected
If the return stack over/underflows, exit Toka

push(long a)
Push a number to the stack.

lit()
Push the value in the following memory location
to the stack
#unpre

= Primitives Provided =

#pre
heap
#unpre} 1175294932


#--------------------------------------------------
# WordClasses

page WordClasses {An implementation strategy adopted from HelFORTH. Each quote, primitive,
and data structure has a <i>class</i> assigned to it. These classes are
aware of the current compiler state (<i>on</i> or <i>off</i>), and may be
aware of other aspects of the Toka system as well.

When an item is found, the corresponding <i>class handler</i> is invoked.
The primary classes you will encounter in Toka are:


== is ==

This is the most common class. 

* Compiling: compile a call to the quote.
* Interpreting: invoke the quote.

== is-macro ==

A special case, these are used for quotes that need to be invoked
whenever they are encountered. Macro class is used for creating strings
(via <b>"</b>) and symbolic creation of characters (via <b>char:</b>).

* Compiling: invoke the quote.
* Interpreting: invoke the quote.

== is-data ==

This is the second most common class. It is used for all data structures,
including variables, arrays, and strings.

* Compiling: compile the value into the quote.
* Interpreting: leave the value on the stack.} 1177736583


#--------------------------------------------------
# Words and Their Uses

page {Words and Their Uses} {= Primitives =

These are words that are built into the Toka executable. If the
<b>bootstrap.toka</b> can not be found, these are the only words 
that will be provided.

#pre
<<       ( ab-c )    Shift 'b' left by 'a' bits
>>       ( ab-c )    Shift 'b' right by 'a' bits
and      ( ab-c )    Perform a bitwise AND
or       ( ab-c )    Perform a bitwise OR
xor      ( ab-c )    Perform a bitwise XOR
#args    (  -n )     Return the number of arguments
arglist  (  -a )     Return a pointer to the 
                     argument list.
<        ( ab-f )    Compare 'a' and 'b', return
                     a flag
>        ( ab-f )    Compare 'a' and 'b', return
                     a flag
=        ( ab-f )    Compare 'a' and 'b', return
                     a flag
<>       ( ab-f )    Compare 'a' and 'b', return
                     a flag
.        ( n- )      Display the TOS
emit     ( c- )      Display the ASCII character
                     for TOS
type     ( a- )      Display a string
bye      ( - )       Quit Toka
#        ( n- )      Push the following cell to
                     the stack.
@        ( a-n )     Fetch the value in memory
                     location 'a'
!        ( na- )     Store 'n' to memory location
                     'a'
c@       ( a-n )     Fetch a byte from memory
                     location 'a'
c!       ( na- )     Store byte 'n' to memory
                     location 'a'
copy     ( sdc- )    Copy 'c' bytes from 's' to
                     'd'
cell-size ( -n )     Return the size of a cell
char-size ( -n )     Return the size of a char
:words   ( - )       Display a list of all named
                     quotes and data
:stack   ( - )       Display all values on the
                     data stack
:gc      (  -  )     Display information about
                     the garbage collection list
:see     (  "- )     Decompile the specified quote
is       ( a"- )     Attach a name to a quote
         ( a$- )     Non-parsing form
is-macro ( a"- )     Attach a name to a quote
         ( a$- )     Non-parsing form
is-data  ( a"- )     Attach a name to data memory
         ( a$- )     Non-parsing form
`        ( "-a )     Return a quote corresponding
                     to the specified word.
         ( $-a )     Non-parsing form
from     ( "- )      Set the library to import from
         ( $- )      Non-parsing form
import   ( n"- )     Import a function taking 'n'
                     arguments.
         ( n$- )     Non-parsing form
as       ( "- )      Rename the last defined word
         ( $-  )     Non-parsing form
file.open  ( $m-n )  Open a specified file with
                     the specified mode.
file.close ( n- )    Close the specified file handle
file.read  ( nbl-r ) Read 'l' bytes into buffer 'b'
                     from file handle 'n'. Returns
                     the number of bytes read.
file.write ( nbl-w ) Write 'l' bytes from buffer 'b'
                     to file handle 'n'. Returns
                     the number of bytes written.
file.size  ( n-s )   Return the size (in bytes)
                     of the specified file.
file.seek  ( nom-a ) Seek a new position in the
                     file. Valid modes are
                     START, CURRENT, and END. These
                     have values of 1, 2, and 3.
file.pos   ( n-a )   Return a pointer to the current
                     offset into the file.
keep     ( a-a )     Mark quotes/allocated memory
                     as permanent.
gc       ( - )       Clean the garbage
malloc   ( n-a )     Allocate 'n' bytes of memory
heap     ( -a )      Variable pointing to the top
                     of the local heap
compiler ( -a )      Variable holding the compiler
                     state
count    ( a-ac )    Return an address/count pair
                     for a string
+        ( ab-c )    Add TOS and NOS
-        ( ab-c )    Subtract TOS from NOS
*        ( ab-c )    Multiply TOS by NOS
/mod     ( ab-cd )   Divide and get remainder
base     ( -a )      Variable containg the current
                     numeric base
parser   ( -a )      Variable holding current parser
                     mode.
escape-sequences ( -a)  Variable determining if
                        escape sequences are used.
>number  ( a-nf )    Attempt to convert a string
                     to a number
parse    ( d-a )     Parse until the character 
                     represented by 'd' is found.
                     Return a pointer to the string
include  ( "- )      Attempt to open a file and
                     add it to the input stack.
         ( $- )      Non-parsing form
needs    ( "- )      Attempt to include a file
                     from the library (normally
                     /usr/share/toka/library)
         ( $- )      Non-parsing form
end.     ( - )       Remove the current file from
                     the input stack
[        ( -a )      Create a new quote
]        ( - )       Close an open quote
invoke   ( a- )      Execute a quote
iterate  ( na- )     Execute a quote 'n' times
+iterate ( na- )     Execute a quote 'n' times
ifTrueFalse ( fab- ) Invoke 'a' if 'f' flag is
                     true, 'b' if false.
recurse  ( - )       Compile a call to the top
                     quote.
i        ( -n )      Return the current loop index
whileTrue  ( a- )    Execute quote. If the quote
                     returns TRUE, execute again.
                     otherwise end the cycle.
whileFalse ( a- )    Execute quote. If the quote
                     returns FALSE, execute again.
                     otherwise end the cycle.
dup      ( n-nn )    Duplicate the TOS
drop     ( n- )      Drop the TOS
swap     ( ab-ba )   Exchange the TOS and NOS
>r       ( n- )      Push TOS to return stack, DROP
r>       ( -n )      Pop TORS to the data stack
depth    ( -n )      Return the number of items
                     on the stack
#unpre

= Bootstrap =

These are additional words, provided in <b>bootstrap.toka</b>.
They significantly expand the core language.

#pre
#!       ( "- )      Parse to the end of the line
                     and scrap the results.
(        ( "- )      Parse until ) is found and scrap
                     the results
SPACE    ( -n )      ASCII value for SPACE character
CR       ( -n )      ASCII value for CR character
LF       ( -n )      ASCII value for LF character
ESC      ( -n )      ASCII value for ESC character
TAB      ( -n )      ASCII value for TAB character
wsparse  ( -a )      Parse until a SPACE is encountered
lnparse  ( -a )      Parse to the end of the line,
                     leave the resulting string on the
                     stack.
FALSE    ( -f )      Value returned for FALSE
TRUE     ( -f )      Value returned for TRUE
ifTrue   ( fq- )     Execute quote ('q') if flag ('f') is TRUE
ifFalse  ( fq- )     Execute quote ('q') if flag ('f') is FALSE
>char    ( n-c )     Convert the value on TOS to a single character
char:    ( "-c )     Parse ahead and return one character
"        ( "-$ )     Parse until " is encountered and return a string
cr       ( - )       Display a CR character
space    ( - )       Display a space
tab      ( - )       Display a tab
t:       ( "- )      Parse to the end of the line, display
                     the results.
clear    ( - )       Clear the screen
normal   ( - )       Set the colors back to the default
bold     ( - )       Set the bold attribute for the foreground color
black    ( - )       Set the foreground color to black
red      ( - )       Set the foreground color to red
green    ( - )       Set the foreground color to green
yellow   ( - )       Set the foreground color to yellow
blue     ( - )       Set the foreground color to blue
magenta  ( - )       Set the foreground color to magenta
cyan     ( - )       Set the foreground color to cyan
white    ( - )       Set the foreground color to white
onBlack  ( - )       Set the background color to black
onRed    ( - )       Set the background color to red
onGreen  ( - )       Set the background color to green
onYellow ( - )       Set the background color to yellow
onBlue   ( - )       Set the background color to blue
onMagenta( - )       Set the background color to magenta
onCyan   ( - )       Set the background color to cyan
onWhite  ( - )       Set the background color to white
nip      ( xy-y )    Remove the second item on the stack
rot      ( abc-bca ) Rotate top three values on stack
-rot     ( abc-acb ) Rotate top three values on stack twice
over     ( xy-xyx )  Put a copy of NOS above the TOS
tuck     ( xy-yxy )  Put a copy of TOS under NOS     
2dup     ( xy-xyxy ) Duplicate the top two items on the stack
2drop    ( xy- )     Drop TOS and NOS
reset    ( *- )      Drop all items on the stack
r@       ( -x )      Get a copy of the top item on the return stack
1+       ( x-y )     Increase value on stack by 1
1-       ( x-y )     Decrease value on stack by 1
negate   ( x-y )     Invert the sign of TOS
/        ( xy-z )    Divide two numbers
mod      ( xy-z )    Divide two numbers and get remainder
not      ( x-y )     Invert the value 'x'
*/       ( abc-d )   (a*b)/c
chars    ( x-y )     Multiply TOS by char-size. Useful w/arrays
char+    ( x-y )     Increase TOS by char-size
char-    ( x-y )     Decrease TOS by char-size
cells    ( x-y )     Multiply TOS by cell-size. Useful w/arrays
cell+    ( x-y )     Increase TOS by cell-size
cell-    ( x-y )     Decrease TOS by cell-size
+!       ( xa- )     Add 'x' to the value in address 'a'
-!       ( xa- )     Subtract 'x' from the value in address 'a'
on       ( a- )      Set a variable to TRUE
off      ( a- )      Set a variable to FALSE
toggle   ( a- )      Toggle a variable between TRUE and FALSE
variable ( "- )      Create a variable
variable| ( "- )     Create multiple variables
hex      ( - )       Set the base to hexadecimal (16)
decimal  ( - )       Set the base to decimal (10)
binary   ( - )       Set the base to binary (2)
octal    ( - )       Set the base to octal (8)
"R"      ( -x )      Mode for file.open
"R+"     ( -x )      Mode for file.open
"W"      ( -x )      Mode for file.open
"W+"     ( -x )      Mode for file.open
"A"      ( -x )      Mode for file.open
"A+"     ( -x )      Mode for file.open
START    ( -x )      Mode for file.seek
CURRENT  ( -x )      Mode for file.seek
END      ( -x )      Mode for file.seek
file.slurp        ( $-a )   Read a file into a dynamically allocated buffer 
is-array          ( n"- )   Create an array of size 'n'
get-element       ( ia-n )  Get element 'i' from array 'a'
put-element       ( nia- )  Put value 'n' into element 'i' of array 'a'
get-char-element  ( ia-n )  Get char-size element 'i' from 
                            array 'a'
put-char-element  ( nia- )  Put char-size value 'n' into element 'i' of 
                            array 'a'
<list>   ( -a )      Stores a list of pointers used by { and }
{        ( - )       Start a scoped area
}        ( - )       End a scoped area
#unpre} 1177812647


# End of Notebook Database File
