

Introduction
Toka is a small language with many similarities to Forth. It was designed to be be easily learned, extended, and used. In addition, it acts a research project, and thus has an evolving set of features. 
It has a minimal form of garbage collection, decompiler, makes use of threaded code, and provides a small number of carefully selected primitives. In addition, it also features a standard bootstrap module (loaded on startup), which greatly expands the core primitives into a useful language. 

Building
At a command line, run one of the following: 
------------------------------------------------
 make linux
 make bsd
 make windows
------------------------------------------------


If you want a binary with debugging information, try this command line instead: 
------------------------------------------------
 make CFLAGS=-g
------------------------------------------------



Installation
You should now install Toka. This typically needs to be done as the root user. 
------------------------------------------------
 make install PORTNAME
------------------------------------------------


------------------------------------------------
*************************************************
* If you are the only user on your machine, you *
* can set permissions to allow you to update a  *
* Toka installation without being root. Try:    *
*                                               *
*   chown -R username /usr/bin/toka             *
*   chown -R username /usr/share/toka           *
*************************************************
------------------------------------------------



Running Toka
You should now be able to load and run Toka. Load as follows: 
------------------------------------------------
 toka
------------------------------------------------



Language Basics
The Toka language draws from Forth, so if you are already familiar with concatenative, stack based languages, learning it should not prove difficult. If you come from a C background, it will be a bit different. 

The Stack
Toka is based on a dual stack virtual machine. The primary (data) stack is used to pass parameters. The alternate (return) stack contains addresses used during call/return operations and can temporarily hold values during execution of code. 
------------------------------------------------
*************************************************
* The alternate stack MUST be kept balanced. If *
* you push values to it, you must remove them   *
* before execution of the code finishes or Toka *
* may crash.                                    *
*************************************************
------------------------------------------------



Quotes
The basic building block in the Toka language is called a quote. These are small blocks of compiled code. Quotes can be created at any time and nested up to 8 levels deep. 
When first created a quote is anonymous; however a name can be associated with it after it has been created. 
To create quotes enclose the code in a [ ] pair. After closing the quote with ], a reference to the quote is left on the stack. An example follows. 
------------------------------------------------
 [ 0 100 [ dup . 1 + ] iterate drop ]
------------------------------------------------


------------------------------------------------
*************************************************
* Quotes can be up to 64 elements in length;    *
* this is a best case scenario as numbers,      *
* nested quotes, and references to named quotes *
* each take two elements which reduces this to  *
* 32 elements in most cases.                    *
*************************************************
------------------------------------------------


Names can be given to quotes via "is" and "is-macro". Most named quotes will be created via "is". The "is-macro" form only allows the quotes to be run during compilation of new quotes. 
Consider the earlier example: 
------------------------------------------------
 [ 0 100 [ dup . 1 + ] iterate drop ] is count-to-100
------------------------------------------------


This adds a name ("count-to-100") refering to this quote to the dictionary. This is called a "word". Now take a look at is-macro: 
------------------------------------------------
 [ 34 parse type ] is-macro ."
 [ ." inside a def" 1 2 + . ." still inside" ] is foo
 foo
------------------------------------------------



Data
In addition to quotes, you will generally need to allocate space for variables, buffers, etc. Toka allows for this via "malloc". An example: 
------------------------------------------------
 1024 1024 * malloc
------------------------------------------------


This returns a pointer to a 1MiB memory region. The memory will be 0'd out. All memory allocations (this includes the memory for each created quote, temporary data structures used by Toka, and all memory you allocate) are managed by a garbage collector. 
If you want to keep a memory region around, there are two ways to do so: 
------------------------------------------------
* keep
* is  is-macro  is-data
------------------------------------------------


If you do not name the allocated memory (or quote) and do not invoke "keep" on the pointer, the garbage collector will eventually deallocate the memory. You can force an earlier collection by invoking "gc", or view information about the current memory useage by invoking ".gc" 

Garbage Collection
Toka makes use of a garbage collector for dynamic memory allocations. This allows fairly liberal use of dynamically allocated memory without worry of memory leaks. 
The model is pretty simple. To allocate memory, gc_alloc() is called. This is passed the number of elements, the size of an element, and a hint regarding whether this is known to be temporary or may be permanent. 
The garbage collector maintains two lists of allocations. When either of these is filled, the gc() routine is called to clean them up. Any item that was flagged as temporary using gc_alloc() is freed by gc(). It also frees up to 32 allocations from the primary list each time it is called. To help prevent temporary items from being corrupted by future allocations, only 64 temporary allocations will be freed per call of gc(). 
Another routine, gc_keep() skims down through the list of allocations (most recent to oldest) to find a specific pointer. When found, that (and any allocation that follows, are removed from the list making them permanent allocations. (This assumes that subsequent allocations are referenced by the one you desire to keep. In a normal Toka build this is safe.) 
Information regarding the current status of the garbage collection subsystem can be obtained via gc_info(). 

The Foreign Function Interface
Toka has an optional set of words to map in and allow use of external library functions. This is called the Foreign Function Interface, or FFI. 
If you built the FFI support into Toka, you will have two new words. The first, "from", is used to select a library to import functions from. 
------------------------------------------------
 from libc.so
 from libgtk-2.0-x11.so
------------------------------------------------


After setting the active library you can "import" functions from it: 
------------------------------------------------
 from libc.so
 1 import puts
------------------------------------------------


The "import" word takes the number of arguments and the name of the function to import. When you are ready to use the imported function, just invoke its name: 
------------------------------------------------
 from libc.so
 1 import puts
 " hello, world!" puts
------------------------------------------------


Imported functions will leave their return value on the stack. 
In addition to these words, the decompiler has also been extended to recognize FFI functions, displaying a form like: 
------------------------------------------------
 [ address #args <ffi> ]
------------------------------------------------



The examples
Toka comes with numerous examples, showing use of the basic language as well as the included library. 
------------------------------------------------
Basic Examples
- hello.toka
  A simple "Hello, World!" script
- show-args.toka
  Echos all arguments passed to it.
- tests.toka
  Perform a set of basic tests on the Toka installation.
  These cover much of the core Toka functionality.

Basic Shell Tools
- rm.toka
  Remove a file
- cat.toka
  Display a text file
- timedate.toka
  Display the current time and date
  Uses the "time" library.

Networking
- echo-server.toka
  A simple echo server. This uses recursion and needs to
  be run under socket(1). Recommended command line is:
    socket -slfp ./echo-server.toka 9998
  Then you can:
    telnet 0.0.0.0 9998
  And test it. Get socket(1) from:
    http://www.jnickelsen.de/socket/

Benchmarking
- timed-fib.toka
  Uses the "time" library to track the approximate
  time required to calculate "35 fib"
- fib.toka
  Calculate "35 fib". The time can be tracked with the
  standard "time" utility on Linux and BSD systems.
------------------------------------------------



Libraries
As the Toka language is pretty minimal, a library of additional code has begun to be written. These can be loaded by doing: 
------------------------------------------------
needs libraryname
------------------------------------------------


In a normal installation, these will be kept in /usr/share/toka/library 
------------------------------------------------
- console
  Expands on the minimal console interface in Toka.
  This allows for colors (foreground/background),
  positioning of the cursor, and printf.
- ctype
  Functions from ctype.h
- debug
  Expands on the debugging words in Toka.
- math
  Additional math related functionality, including
  some functionality from math.h
- strings
  Additional string processing functionality.
- time
  Basic time functions, useful for basic benchmarking
------------------------------------------------

