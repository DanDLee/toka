# Notebook Database File

#--------------------------------------------------
# bits.c

page bits.c {#pre
lshift()
Shift TOS left by NOS bits

rshift()
Shift TOS right by NOS bits

and()
Perform a bitwise AND

or()
Perform a bitwise OR

xor()
Perform a bitwise XOR
#unpre} 1175221783


#--------------------------------------------------
# Building

page Building {To build Toka, you will need the following:

* GCC 2.9x, 3.x, or 4.x
* Make (GNU Make is recommended, though others may work)
* Alternative: You can also use <i>Rebuild</i> instead of Make

The process using Make:

#pre
  make
#unpre

The process using Rebuild:

#pre
  cd source
  rebuild toka
#unpre
} 1175233124


#--------------------------------------------------
# class.c

page class.c {#pre
forth_class()
If compiling, compile the xt into the current
quote. If interpreting, call the word.

self_class()
Always call the word

data_class()
If compiling, compile a call to lit() and then
inline TOS into the following location. Otherwise
leave TOS alone.

quote_super_class()
Always invoke the quote.

quote_class()
Handler for quotes; this takes two cells, one
which is a call to this function, the other is
the pointer to the quote to invoke.

quote_macro_class()
If compiling, invoke the quote. If interpreting,
silently ignore it.

quote_forth_class()
Perform data_class() semantics, then, if 
compiling, compile a call to invoke(). Otherwise,
invoke() is called with the xt on TOS.
#unpre} 1175221809


#--------------------------------------------------
# cmdline.c

page cmdline.c {#pre
Variables:
  long arg_count
  Holds the number of command line arguments

  char *arg_list[12]
  Holds the list of command line arguments. 

num_args()
Return the number of arguments, not including the
file names used to launch this program.

get_arg_list()
Return the number of arguments, not including the
file names used to launch this program.

build_arg_list(char *args[], long count)
Copy pointers to the command line arguments to
arg_list[]. Also sets arg_count.
#unpre} 1175221831


#--------------------------------------------------
# conditionals.c

page conditionals.c {#pre
less_than()
Compare TOS and NOS, return a flag.

greater_than()
Compare TOS and NOS, return a flag.

equals()
Compare TOS and NOS, return a flag.

not_equals()
Compare TOS and NOS, return a flag.
#unpre} 1175221847


#--------------------------------------------------
# console.c

page console.c {#pre
dot()
Display the number on TOS using the current base
if possible.

emit()
Display the character TOS corresponds to. Consumes
TOS.

type()
Display the string TOS points to. Consumes TOS.

bye()
Quit Toka
#unpre
} 1175233346


#--------------------------------------------------
# data.c

page data.c {#pre
make_literal()
Compile a call to lit() and then place TOS into
the next memory location.

fetch()
Fetch the value in the memory location pointed to
by TOS.

store()
Store NOS into the memory location specified by
TOS.

fetch_char()
Fetch the value in the memory location pointed to
by TOS. This version reads a single byte.

store_char()
Store NOS into the memory location specified by
TOS. This version stores a single byte.

copy()
Copies 'count' bytes from 'source' to 'dest'. The
stack form for this is:
  source dest count
The memory locations can overlap.

cell_size()
Push the size of a cell to the stack.

char_size()
Push the size of a char to the stack
#unpre
} 1175233375


#--------------------------------------------------
# debug.c

page debug.c {#pre
words()
Display a list of all named words

display_stack()
Display all items on the stack.

gc_info()
Display information about Toka's memory use
#unpre
} 1175233399


#--------------------------------------------------
# decompile.c

page decompile.c {#pre
long resolve_name(Inst xt)
Search for a name in the dictionary that corresponds
to 'xt'. Display it if found, and return a flag.

decompile(Inst *xt)
Decompile a quote and its children and display the
result on the screen.

see()
Decompile the quote on the stack.
#unpre
} 1175233419


#--------------------------------------------------
# dictionary.c

page dictionary.c {#pre
Variables:
  ENTRY dictionary[4096];
  Holds the dictionary entries, up to 4096

  long last
  A pointer to the most recent dictionary entry

add_entry(char *name, Inst xt, Inst class)
Add an entry to the dictionary.

name_attach(void *class)
Attach a name (from the input stream) to the 
specified quote address. This word is given the
semantics of the specified class.

name_quote()
Attach a name (from the input stream) to the 
specified quote address. This word is given the
semantics of quote_forth_class().

name_super()
Attach a name (from the input stream) to the 
specified quote address. This word is given the
semantics of quote_super_class().

name_quote_macro()
Attach a name (from the input stream) to the 
specified quote address. This word is given the
semantics of quote_macro_class().

name_data()
Attach a name (from the input stream) to the data
at the specified address. Semantics are the same
as the data_class().

find_word()
Search for a word (name taken from the string
passed on TOS) in the dictionary. Returns the
xt, class, and a flag of -1 if found. If not
found, returns only a flag of 0.

return_quote()
Find a name (from the input stream) and return a
quote that corresponds to the word.
#unpre
} 1175233445


#--------------------------------------------------
# ffi.c

page ffi.c {#pre
Variables:
  void *library
  Pointer to the most recently opened library

ffi_invoke()
Call a foreign function. This translates between
Toka and CDECL calling conventions.

ffi_from()
Select a library to load from.

ffi_import()
Import and name an external function. This wraps
the imported function in a quote.

ffi_rename()
Rename the most recently defined word in the
dictionary.
#unpre
} 1175233462


#--------------------------------------------------
# files.c

page files.c {#pre
file_open()
Open a file using the specified mode. Modes are
a direct map to the fopen() modes: "r", "r+", "w",
"w+", "a", and "a+". Numeric values for these are
1 - 6, in that order.

file_close()
This is just a simple wrapper over fclose().

file_read()
This is just a simple wrapper over fread().

file_write()
This is just a simple wrapper over fwrite().

file_size()
This is just a simple wrapper over fstat() which
returns the size of the file.

file_seek()
This is just a simple wrapper over fseek().

file_pos()
This is just a simple wrapper over ftell().
#unpre
} 1175233479


#--------------------------------------------------
# First Steps

page {First Steps} {} 1175216561


#--------------------------------------------------
# gc.c

page gc.c {#pre
Variables:
  GCITEM gc_list[128]
  Holds the list of items marked as garbage

  long gc_depth
  A pointer to the top of the garbage collection
  list

  GCITEM gc_trash[128]
  Holds the short list of items marked as garbage

  long gc_tdepth
  A pointer to the top of the short garbage
  collection list

  long gc_used
  Contains the total size of all currently used
  memory, including permanent quotes.

  long gc_objects
  Contains the total number of objects that are
  currently existing, including permanent ones.

gc_alloc(long items, long size, long type)
Allocate the requested memory and add it to the
garbage collection list.
If type is set to 0, add to the normal garbage
collection list. If set to 1, add to the short
list of known garbage items which can be safely
freed at the next gc().
If the allocation fails, gc() is called, and the
allocation is retried. If it still fails, an
error is reported and Toka is terminated.

gc_keep()
Remove the specified address (and any childern it
has registered) from the garbage collection list.
If the TOS is not an allocated address, this will
silently ignore it.

gc()
Free the oldest allocations on the garbage list.
Will free up to 64 trash entries and 32 normal
entries per call.

toka_malloc()
Allocate TOS bytes of memory. Returns a pointer to
the allocated memory.
#unpre
} 1175233499


#--------------------------------------------------
# Home

page Home {Hello, and welcome to Toka!

Toka is a small language drawing influence primarily from Forth. It is
designed to be easy to learn, expand on, and yet remains useful enough
for actual programs to be written in it.

* [Building] and [Installation]
* [First Steps]
* [Words and Their Uses]


Internals:
* [bits.c]
* [class.c]
* [cmdline.c]
* [conditionals.c]
* [console.c]
* [data.c]
* [debug.c]
* [decompile.c]
* [dictionary.c]
* [ffi.c]
* [files.c]
* [gc.c]
* [initial.c]
* [interpret.c]
* [math.c]
* [parser.c]
* [quotes.c]
* [stack.c]
* [toka.c]
* [vm.c]} 1175217413


#--------------------------------------------------
# Index

page Index {[@pageIndex@]} 1026586734


#--------------------------------------------------
# initial.c

page initial.c {#pre
build_dictionary()
Attach names and classes to the various initial
words in the Toka language.
#unpre
} 1175233515


#--------------------------------------------------
# Installation

page Installation {If you built it using Make:

#pre
  make install
#unpre

Or, if you built it using Rebuild:

#pre
  cp source/toka /usr/bin
  mkdir -p /usr/share/toka
  cp bootstrap.toka /usr/share/toka
#unpre

After installation, run the test suite:

#pre
  make tests
#unpre

Or:

#pre
  cd examples
  toka tests.toka >test.log
#unpre

Look for any failures in the test.log. If you encounter a problem, please
forward the test.log to charles.childers@gmail.com along with some
basic information about your system (OS, CPU type)} 1175217069


#--------------------------------------------------
# interpret.c

page interpret.c {#pre
Variables:
  long compiler
  When set to 0, interpret; when set to -1, 
  compile. This is checked by the various word
  classes defined in class.c

  char *scratch
  Temporary holding area used by the parser and
  other routines.

  char *tib
  Pointer to the text input buffer.

count()
Perform strlen() on the string passed on TOS. This
returns the string and the count on the stack. The
count is increased by 1 to include the trailing 
ASCII 0.

notfound()
Display an error message if a word was not found
or able to be converted to a number. It takes a
string from the stack.

interpret()
Accept and process input.
#unpre
} 1175233541


#--------------------------------------------------
# math.c

page math.c {#pre
add()
Add TOS to NOS

subtract()
Subtract TOS from NOS

multiply()
Multiply TOS by NOS

divmod()
Divide and return the result, including remainder
#unpre
} 1175233600


#--------------------------------------------------
# New Pages

page {New Pages} {To create a new page,

* Add a link to it in this page (or on any other page where the link would
  be more appropriate):
** Press the "Edit" button.
** Go to the bottom of the page (or anywhere, really).
** Type the page's name in square brackets, &lb;Like This&rb;.
** Press the "Done" button.
* Click on the link.
* On the Status Line, down at the bottom of the window, Notebook will ask
  if you want to create the page.  Type "yes" or "y", and press Enter.

<h>New Pages</h>

* [Tour]
* [Sandbox]} 1102291321


#--------------------------------------------------
# parser.c

page parser.c {#pre
Variables:
  FILE *input[]
  Current file stream to parse from. Setup as
  an array of 8 inputs.

  long isp
  Pointer to the most recent input source in the array

  long base
  Holds the current numeric base

  long parser
  When ON (TRUE), system parsing words will parse. When
  OFF (FALSE), they will take a string from the stack.

to_number()
Attempt to convert a string (on TOS) to a number.
This accepts a format of:
  [-]number
If successful, it leaves the number and a flag of
-1 on the stack. Otherwise, it leaves the original
string, and a flag of 0.

parse()
Parse the input buffer until the character passed
on TOS is found, or until the end of the line is
encountered. Return a pointer to the resulting
string on the stack.

get_token(char *s, long delim)
Return a string (in "s") up to the specified 
delimiter. This also puts the resulting string 
on the stack.

long include_file(char *s)
Attempt to open a file ("s") and add it to the
top of the input stack.

include()
Take a filename off the stack, attempt to open
it and add it to the input stream if successful.

needs()
Take a filename off the stack. Attempt to open it
from the library, and add it to the input stream 
if successful.

force_eof()
Remove the current file from the input stack. This
can be used to abort an include.
#unpre
} 1175233637


#--------------------------------------------------
# quotes.c

page quotes.c {#pre
Variables:
  QUOTE quotes[8]
  Holds details about the compiler state, heap,
  etc for quotes during compilation.

  long qdepth
  Tracks how deeply the quotes are nested

  long quote_counter
  Tracks the current loop index

  Inst top
  Holds a pointer to the root quote

begin_quote()
Create a new quote. This allocates space for it,
and sets the compiler flag. A pointer to the
quote's start is pushed to the stack.

end_quote()
Terminate the previously opened quote and perform
data_class() semantics.

invoke()
Call a quote (passed on TOS)

iterate()
Repeat execution of a quote (passed on TOS), NOS
number of times.

alt_iterate()
Repeat execution of a quote (passed on TOS), NOS
number of times.

truefalse()
Takes three items (true-xt, false-xt, and a flag)
from the stack. Stack should be passed in as:
  flag true false 
It will execute true if the flag is true, false
otherwise.

recurse()
Compiles a call to the top-level quote. As a
trivial example:
  [ dup 1 > [ dup 1 - recurse swap 2 - recurse + ] true? ] is fib

qlit()
Push the value in the following memory location
to the stack. This is used instead of lit() so
that the decompiler (and eventually debugger) can
reliably identify nested quotes as opposed to 
regular literals.

quote_index()
Return the current loop index (counter)

quote_while()
Return execution of a quote until the quote
returns FALSE.
#unpre
} 1175233659


#--------------------------------------------------
# Recent Changes

page {Recent Changes} {[@recentChanges@]} 1026585675


#--------------------------------------------------
# Sandbox

page Sandbox {This is place to experiment with Notebook's way of marking up text.
Edit this page to see how you type things; then save it to see what it looks
like when you're browsing.

= You Can Have Section Headers =

*	You can have bulleted lists.
*	You can type <b>bold</b>, <i>italic</i>, and <m>monospace</m> text,
	or any combination.
*   You can have <h>inline header text</h>.
*	You can have <s>very small</s> text.
*   You can <x>strike things out</x>.

:	You can simply indent a paragraph without adding a bullet.

Paragraphs end with the first blank line, bullet item, or indented line.
No matter how many lines long a paragraph is, Notebook will wrap it for
display so that it looks nice.

 If you leave a space character at the beginning of a paragraph, the whole
 paragraph is "Preformatted".  That means that it's displayed in a monospace
 font, exactly as is.  It's conventional to put whitespace at the beginning of
 every line of a preformatted paragraph, but that's not necessary.

Preformatted text is useful for typing in tables and things like that.} 1113419698


#--------------------------------------------------
# Search

page Search {[@searchIndex@]} 1175217539


#--------------------------------------------------
# stack.c

page stack.c {#pre
stack_dup()
Duplicate the TOS

stack_drop()
Drop the TOS

stack_swap()
Exchange TOS and NOS

stack_to_r()
Push TOS to return stack, DROP TOS

stack_from_r()
Pop TORS to the data stack

stack_depth()
Return the number of items on the stack
#unpre
} 1175233698


#--------------------------------------------------
# toka.c

page toka.c {#pre
main()
The main entry point into Toka. Sets up the
dictionary and calls interpret().
#unpre
} 1175233711


#--------------------------------------------------
# Tour

page Tour {Welcome to a tour of your new Notebook!

Notebook has many features; this tour will touch on the highlights.  You
can find more information about any of them via the [@helpbtn Help@] menu.

<h>Pages are linked together</h>

The most important feature of Notebook is that a notebook is a collection
of pages, and the pages are linked together.  You've already discovered
this, by clicking [Tour] to get to this page.

: [Click here to continue...|Tour 2]} 1102291376


#--------------------------------------------------
# Tour 3

page {Tour 3} {This page is part of a [tour] of Notebook's features.

= You can style your text =

You can use <b>boldface</b>, <i>italics</i>, and <m>monospace</m> text, or
a combination of <b><i><m>all three</m></i></b>.

You can <x>strikeout</x> any text you like.

You can use a <h>large font</h> for emphasis, or a 
<s>small font</s> for incidental notes.

If you click the Edit button (the one with the pencil on it), you'll see
that the above paragraphs look like this, only not indented:

 You can use <b>boldface</b>, <i>italics</i>, and <m>monospace</m> text, or
 a combination of <b><i><m>all three</m></i></b>.

 You can <x>strikeout</x> any text you like.

 You can use a <h>large font</h> for emphasis, or a 
 <s>small font</s> for incidental notes.

If you put whitespace at the beginning of a paragraph, like those two just
above this have, then they get displayed "preformatted", just as you typed them.

: [Click here to continue...|Tour 4]} 1113419869


#--------------------------------------------------
# Tour 5

page {Tour 5} {This page is part of a [tour] of Notebook's features.

<h>You can find your pages</h>

You can always find any page you create in Notebook, even if you don't
remember how to get there by clicking on links.

* You can press the Index button (the one with the Book on it), or select
  "Page/Index" from the menu, to see an alphabetical list of the pages in your Notebook.

* You can select "Page/Recent Changes" from the menu to see a list of
  all of your pages, starting with the ones you've edited most recently.

* You can type any text you like in the "Search" field above, and press
  Enter, and Notebook  
  will show you a list of pages that contain it.

Try it!  Once you're done, click the Back button (the one with the arrow
pointing to the left) repeatedly until you're
back to this page--or find [Tour 5] in the index!

: [Click here to continue...|Tour 6]} 1113419918


#--------------------------------------------------
# Tour 6

page {Tour 6} {This page is part of a [tour] of Notebook's features.

<h>You can do magic!</h>

Notebook is programmed in a language called Tcl.  
You can use [@helpbtn "the Tcl language"@] in your pages to do magic.  There are
two kinds of magic: [@helpbtn "magic button"@]s and 
[@helpbtn "embedded macro"@]s.
Both of them are represented on this page (you'll see them if you edit
this page).

A magic button looks like a link, but it's colored magenta instead of blue.
Whereas a link just takes you to the named page, a magic button executes
a [@helpbtn "Notebook command"@].  There are lots of magic buttons on 
this page; see what happens if you click them.

An embedded macro is a [@helpbtn "Notebook command"@] that's executed 
whenever the page displays.  It returns some text that's included into
the page just as though you'd typed it.  If you edit this page, then toward
the top you'll see an embedded macro that looks like this:

:	<m>&lb;@helpbtn "the Tcl language"@&rb;</m>

Here, "helpbtn" is an embedded macro that creates a magic button that pops up
the Help window with the named topic, as if you'd typed this:

	[%the Tcl language|showhelp "the Tcl language"%]

Of course, the macro is much shorter because it doesn't need to repeat the
topic text.  "showhelp" is a command that pops up Notebook's on-line help
and makes it go to the specified topic. 

: [Click here to continue...|Tour 7]} 1102291940


#--------------------------------------------------
# Tour 7

page {Tour 7} {This page is part of a [tour] of Notebook's features.

<h>But wait--there's more!</h>

Notebook can do lots of other things as well.  If you create a page you don't
like, you can delete it.  If you decide you don't like a page's name, you can
rename it; Notebook will automatically update all of the links.  You can
define new [@helpbtn "Notebook commands"@] on your [User Code] page, 
and use them in [@helpbtn "embedded macro"@]s and [@helpbtn "magic button"@]s.

And that means you can do almost anything you can think of.} 1028999577


#--------------------------------------------------
# User Code

page {User Code} {Use this page to extend Notebook using the 
[@helpbtn "the Tcl language"@].  Commands you add here can be used as
[@helpbtn "Magic Button"@]s and [@helpbtn "Embedded Macro"@]s.

Note that you can intersperse normal prose in between blocks of Tcl code.

= User Menu =

The [@helpbtn "User Menu"@] pops up when you right-click or control-click 
on a page in the [@helpbtn "Page Browser"@].  You can customize it however you like.

#Tcl
usermenu {
    Back back-page
    Home {goto-page Home}
}
#unTcl

= Edit Menu =

The [@helpbtn "Edit Menu"@] pops up when you right-click or control-click 
on a page in the [@helpbtn "Page Editor"@].  You can customize it however you like.

#Tcl
editmenu {
    Undo             undo-change
    Redo             redo-change
    separator {}
    Cut              cut-string
    Copy             copy-string
    Paste            paste-string
    "Insert Page..." insert-page
}
#unTcl

= Example =

The following [@helpbtn "embedded macro"@] used to be used by the
[Tour] to create a [@helpbtn "magic button"@] that said 
"Click here to continue..." and took you to the next page in the tour
when you clicked it.  It's no longer needed, because now you can write
such links directly, like this:

  [Click here to continue...|Tour 2]

Still, it's a nice example of how to write a macro that creates a button.

#Tcl
proc clickToContinue {name} {
	return "\[%Click here to continue...|goto-page [list $name]%\]"
}
#unTcl} 1113420734


#--------------------------------------------------
# vm.c

page vm.c {#pre
Variables:
  Inst *heap
  Pointer into the current heap

  Inst *ip
  The instruction pointer

  long stack[100], rstack[100]
  The data and return stacks

  long sp, rsp
  The stack pointers

vm_run(Inst)
Run through a list of instructions
Side effects:
  modifes *ip

vm_stack_check()
Check for over/underflow and reset if detected
If the return stack over/underflows, exit Toka

push(long a)
Push a number to the stack.

lit()
Push the value in the following memory location
to the stack
#unpre
} 1175233730


#--------------------------------------------------
# Words and Their Uses

page {Words and Their Uses} {Primitives:

#pre
<<       ( ab-c )    Shift 'b' left by 'a' bits
>>       ( ab-c )    Shift 'b' right by 'a' bits
and      ( ab-c )    Perform a bitwise AND
or       ( ab-c )    Perform a bitwise OR
xor      ( ab-c )    Perform a bitwise XOR
#args    (  -n )     Return the number of arguments
arglist  (  -a )     Return a pointer to the 
                     argument list.
<        ( ab-f )    Compare 'a' and 'b', return
                     a flag
>        ( ab-f )    Compare 'a' and 'b', return
                     a flag
=        ( ab-f )    Compare 'a' and 'b', return
                     a flag
<>       ( ab-f )    Compare 'a' and 'b', return
                     a flag
.        ( n- )      Display the TOS
emit     ( c- )      Display the ASCII character
                     for TOS
type     ( a- )      Display a string
bye      ( - )       Quit Toka
#        ( n- )      Push the following cell to
                     the stack.
@        ( a-n )     Fetch the value in memory
                     location 'a'
!        ( na- )     Store 'n' to memory location
                     'a'
c@        ( a-n )    Fetch a byte from memory
                     location 'a'
c!        ( na- )    Store byte 'n' to memory
                     location 'a'
copy     ( sdc- )    Copy 'c' bytes from 's' to
                     'd'
cell-size ( -n )     Return the size of a cell
char-size ( -n )     Return the size of a char
:words   ( - )       Display a list of all named
                     quotes and data
:stack   ( - )       Display all values on the
                     data stack
:gc      (  -  )     Display information about
                     the garbage collection list
:see     (  "- )     Decompile the specified quote
is       ( a"- )     Attach a name to a quote
         ( a$- )     Non-parsing form
is-super ( a"- )     Attach a name to a quote
         ( a$- )     Non-parsing form
is-macro ( a"- )     Attach a name to a quote
         ( a$- )     Non-parsing form
is-data  ( a"- )     Attach a name to data memory
         ( a$- )     Non-parsing form
\        ( "-a )     Return a quote corresponding
                     to the specified word.
         ( $-a )     Non-parsing form
from     ( "- )      Set the library to import from
         ( $- )      Non-parsing form
import   ( n"- )     Import a function taking 'n'
                     arguments.
         ( n$- )     Non-parsing form
as       ( "- )      Rename the last defined word
         ( $-  )     Non-parsing form
file.open  ( $m-n )  Open a specified file with
                     the specified mode.
file.close ( n- )    Close the specified file handle
file.read  ( nbl-r ) Read 'l' bytes into buffer 'b'
                     from file handle 'n'. Returns
                     the number of bytes read.
file.write ( nbl-w ) Write 'l' bytes from buffer 'b'
                     to file handle 'n'. Returns
                     the number of bytes written.
file.size  ( n-s )   Return the size (in bytes)
                     of the specified file.
file.seek  ( nom-a ) Seek a new position in the
                     file. Valid modes are
                     START, CURRENT, and END. These
                     have values of 1, 2, and 3.
file.pos   ( n-a )   Return a pointer to the current
                     offset into the file.
keep     ( a-a )     Mark quotes/allocated memory
                     as permanent.
gc       ( - )       Clean the garbage
malloc   ( n-a )     Allocate 'n' bytes of memory
heap     ( -a )      Variable pointing to the top
                     of the local heap
compiler ( -a )      Variable holding the compiler
                     state
count    ( a-ac )    Return an address/count pair
                     for a string
+        ( ab-c )    Add TOS and NOS
-        ( ab-c )    Subtract TOS from NOS
*        ( ab-c )    Multiply TOS by NOS
/mod     ( ab-cd )   Divide and get remainder
base     ( -a )      Variable containg the current
                     numeric base
parser   ( -a )      Variable holding current parser
                     mode.
>number  ( a-nf )    Attempt to convert a string
                     to a number
parse    ( d-a )     Parse until the character 
                     represented by 'd' is found.
                     Return a pointer to the string
include   ( "- )     Attempt to open a file and
                     add it to the input stack.
          ( $- )     Non-parsing form
needs     ( "- )     Attempt to include a file
                     from the library (normally
                     /usr/share/toka/library)
          ( $- )     Non-parsing form
end.      ( - )      Remove the current file from
                     the input stack
[        ( -a )      Create a new quote
]        ( - )       Close an open quote
invoke   ( a- )      Execute a quote
iterate  ( na- )     Execute a quote 'n' times
+iterate ( na- )     Execute a quote 'n' times
t/f      ( fab- )    Invoke 'a' if 'f' flag is
                     true, 'b' if false.
recurse  ( - )       Compile a call to the top
                     quote.
i        ( -n )      Return the current loop index
while    ( a- )      Execute quote. If the quote
                     returns TRUE, execute again.
                     otherwise end the cycle.
dup      ( n-nn )    Duplicate the TOS
drop     ( n- )      Drop the TOS
swap     ( ab-ba )   Exchange the TOS and NOS
>r       ( n- )      Push TOS to return stack, DROP
r>       ( -n )      Pop TORS to the data stack
depth    ( -n )      Return the number of items
                     on the stack
#unpre

Bootstrap:

#pre
...
#unpre} 1175221749


# End of Notebook Database File
