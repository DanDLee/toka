# Notebook Database File

#--------------------------------------------------
# Arrays

page Arrays {The standard bootstrap adds support for arrays. These are a superset of
variables, and hold either character or numeric data.

The words provided are:

#pre
  is-array          n"-     Create an array of size n. Parses for the name.
  put-element       nia-    Put value (n) into array (a) at index (i)
  get-element       ia-n    Get the value (n) from array (a) at index (i)
  put-char-element  nia-    Put character value (n) into array (a) at index (i)
  get-char-element  ia-n    Get the character value (n) from array (a) at 
                            index (i)
#unpre

= Example =

#pre
  10 cells is-array foo
  0 foo get-element .
  100 0 foo put-element 
  10 1 foo put-element 
  0 foo get-element .
  1 foo get-element .
#unpre

= Tips =

* The command line arguments are stored in an array (*arglist*).
** At 0 is the name of the script
** Actual arguments start at 1.
* Be careful not to exceed the length of your array when giving an index} 1177366441


#--------------------------------------------------
# bits.c

page bits.c {= Use =

This file provides a handful of primitives for manipulating bits.

= Functions Provided =

#pre
lshift()
Shift TOS left by NOS bits

rshift()
Shift TOS right by NOS bits

and()
Perform a bitwise AND

or()
Perform a bitwise OR

xor()
Perform a bitwise XOR
#unpre

= Primitives Provided =

#pre
<<       ( ab-c )    Shift 'b' left by 'a' bits
>>       ( ab-c )    Shift 'b' right by 'a' bits
and      ( ab-c )    Perform a bitwise AND
or       ( ab-c )    Perform a bitwise OR
xor      ( ab-c )    Perform a bitwise XOR
#unpre} 1175295170


#--------------------------------------------------
# Building

page Building {To build Toka, you will need the following:

* GCC 2.9x, 3.x, or 4.x
* Make (Either GNU Make or a BSD Make should work)

For most people, the following should work. If it fails, try checking the
[Ports] page to see if there are any platform-specific instructions. The
process using Make:

#pre
  make
#unpre

The build system should be able to detect the need for libdl.so (Linux,
BeOS) or whether dlopen() and dlsym() are provided by libc.so (BSD). You
can also build a version without the [FFI], but this is not recommended
as it reduces the usefulness of Toka significantly. This can be done via:

#pre
  rm source/ffi
  make CFLAGS=-DNOFFI
#unpre

As a final note, some pieces of documentation can be updated automatically
as well:

#pre
  make docs
#unpre} 1177366685


#--------------------------------------------------
# class.c

page class.c {= Use =

This is where the [WordClasses] are implemented. It does not export any
functions directly to Toka.

= Functions Provided =

#pre
forth_class()
If compiling, compile the xt into the current
quote. If interpreting, call the word.

macro_class()
Always call the word

data_class()
If compiling, compile a call to lit() and then
inline TOS into the following location. Otherwise
leave TOS alone.

quote_macro_class()
Always invoke the quote.

quote_class()
Handler for quotes; this takes two cells, one
which is a call to this function, the other is
the pointer to the quote to invoke.

quote_forth_class()
Perform data_class() semantics, then, if 
compiling, compile a call to invoke(). Otherwise,
invoke() is called with the xt on TOS.
#unpre

= Primitives Provided =

<i>None</i>} 1177736547


#--------------------------------------------------
# cmdline.c

page cmdline.c {= Use =

Build the list of command line arguments that Toka programs can access.
This is a subset of the full arguments passed to the <b>toka</b> executable.

= Functions Provided =

#pre
Variables:
  long arg_count
  Holds the number of command line arguments

  char *arg_list[128]
  Holds the list of command line arguments. 

num_args()
Return the number of arguments, not including the
file names used to launch this program.

get_arg_list()
Return the number of arguments, not including the
file names used to launch this program.

build_arg_list(char *args[], long count)
Copy pointers to the command line arguments to
arg_list[]. Also sets arg_count.
#unpre

= Primitives Provided =

#pre
#args
arglist
#unpre} 1177367383


#--------------------------------------------------
# Commenting Code

page {Commenting Code} {It is generally a good idea to comment your code. Comments will make it
much easier to remember what's going on, can help you locate bugs, and
also be of significant benefit to others who may work on your code at a
later time.

Toka provides two ways to comment your code.

=== In The Listener ===

At the listener (the top level interpreter), you can use <b>#!</b>
comments. These are comments that start with <b>#!</b> and end at the end
of the current line. For example, I often start my programs with a short
information block such as the following:

#pre
  #! ---------------------------------------------------------------
  #! A small HTTP server for Toka
  #!
  #! Developed by:
  #!  Charles R. Childers
  #!  erider
  #!
  #! ---------------------------------------------------------------
#unpre

This style comment works well for blocks, and thus can be very useful at
the start of a function:

#pre
  #! ---------------------------------------------------------------
  #! get-request
  #! This reads a client request of up to 1k into the buffer. The
  #! number of bytes read is returned.
  #! ---------------------------------------------------------------
#unpre

<b>#!</b> comments can <i>not be used inside quotes</i>.

=== Inside Quotes ===

Inside a quote, you can use <b>( ... )</b> comments. These start with a
<b>(</b> and end when <b>)</b> is encountered. Unlike <b>#!</b> comments,
these can span multiple lines and be used inside of quotes. An example:

#pre
  [ 
    connection     (  -a )
    @              ( a-n )
    pClose         ( n-  )
  ] is end-connection
#unpre

In this example, each stack action is mapped out using a <i>stack
comment</i>. This is helpful when learning to use Toka, as it makes it
easier to visualize the stack at each step.} 1177715575


#--------------------------------------------------
# Conditionals

page Conditionals {Toka provides a few basic comparison primitives and one primitive for
handling conditional execution of code. The standard bootstrap also adds
two quotes that extend the conditional functions.

Basic examples:

#pre
  1 100 = [ 1 . ] ifTrue
  1 100 = [ 2 . ] ifFalse
  1 100 = [ 3 . ] [ 4 . ] ifTrueFalse
#unpre

The first case will invoke the quote if the flag returned by <b>=</b> is
TRUE. The second invokes the quote if the flag is FALSE, and the third
form invokes the <b>[ 3 . ]</b> quote if TRUE, or the <b>[ 4 . ]</b>
quote if FALSE.} 1177812670


#--------------------------------------------------
# conditionals.c

page conditionals.c {= Use =

Contains the implementation of the core conditionals. These are words
which do comparisons, and return a flag on the stack.

= Functions Provided =

#pre
less_than()
Compare TOS and NOS, return a flag.

greater_than()
Compare TOS and NOS, return a flag.

equals()
Compare TOS and NOS, return a flag.

not_equals()
Compare TOS and NOS, return a flag.
#unpre

= Primitives Provided =

#pre
<
>
=
<>
#unpre} 1175293903


#--------------------------------------------------
# console.c

page console.c {= Use =

Provide a very basic console interface. The provided interface is
intentionally kept to a minimum, a better console interface can be loaded later.

= Functions Provided =

#pre
dot()
Display the number on TOS using the current base
if possible.

emit()
Display the character TOS corresponds to. Consumes
TOS.

type()
Display the string TOS points to. Consumes TOS.

bye()
Quit Toka
#unpre

= Primitives Provided =

#pre
.
emit
type
bye
#unpre} 1175293981


#--------------------------------------------------
# Constants

page Constants {For data that does not change, a <i>constant</i> can be created as
follows:

#pre
  100 is-data OneHundred
  " /home/crc/htdocs/" is-data docroot
#unpre

The first example takes the number 100, and assigns a name (OneHundred)
to it. The name can now be used as a symbolic constant at the listener or
inside a quote. The second example creates a named pointer to a string,
which can also be used at the listener or inside quotes.

The use of constants is encouraged as it makes code easier to read and
maintain. They have minimal impact on performance, and are significantly
faster to use than variables.} 1177888754


#--------------------------------------------------
# data.c

page data.c {= Use =

These are words useful for accessing and modifying data.

= Functions Provided =

#pre
make_literal()
Compile a call to lit() and then place TOS into
the next memory location.

fetch()
Fetch the value in the memory location pointed to
by TOS.

store()
Store NOS into the memory location specified by
TOS.

fetch_char()
Fetch the value in the memory location pointed to
by TOS. This version reads a single byte.

store_char()
Store NOS into the memory location specified by
TOS. This version stores a single byte.

copy()
Copies 'count' bytes from 'source' to 'dest'. The
stack form for this is:
  source dest count
The memory locations can overlap.

cell_size()
Push the size of a cell to the stack.

char_size()
Push the size of a char to the stack
#unpre

= Primitives Provided =

#pre
char-size
cell-size
copy
c!
c@
!
@
#
#unpre} 1175294055


#--------------------------------------------------
# debug.c

page debug.c {= Use =

This provides a very small collection of simple tools that can be helpful
when trying to track down bugs. It is not intended to be a full-scale
debugging tool.

= Functions Provided =

#pre
words()
Display a list of all named words

display_stack()
Display all items on the stack.

gc_info()
Display information about Toka's memory use
#unpre

= Primitives Provided =

#pre
:words
:stack
:gc
#unpre} 1176258298


#--------------------------------------------------
# decompile.c

page decompile.c {= Use =

This allows for decompiling a quote and displaying the source needed to
recreate it. 

= Functions Provided =

#pre
long resolve_name(Inst xt)
Search for a name in the dictionary that corresponds
to 'xt'. Display it if found, and return a flag.

decompile(Inst *xt)
Decompile a quote and its children and display the
result on the screen.

see()
Decompile the quote on the stack.
#unpre

= Primitives Provided =

#pre
:see
#unpre} 1175294160


#--------------------------------------------------
# dictionary.c

page dictionary.c {= Use =

This file provides the functionality to create new dictionary entries and
search for a specific entry.

= Functions Provided =

#pre
Variables:
  ENTRY dictionary[4096];
  Holds the dictionary entries, up to 4096

  long last
  A pointer to the most recent dictionary entry

add_entry(char *name, Inst xt, Inst class)
Add an entry to the dictionary.

name_attach(void *class)
Attach a name (from the input stream) to the 
specified quote address. This word is given the
semantics of the specified class.

name_quote()
Attach a name (from the input stream) to the 
specified quote address. This word is given the
semantics of quote_forth_class().

name_quote_macro()
Attach a name (from the input stream) to the 
specified quote address. This word is given the
semantics of quote_macro_class().

name_data()
Attach a name (from the input stream) to the data
at the specified address. Semantics are the same
as the data_class().

find_word()
Search for a word (name taken from the string
passed on TOS) in the dictionary. Returns the
xt, class, and a flag of -1 if found. If not
found, returns only a flag of 0.

return_quote()
Find a name (from the input stream) and return a
quote that corresponds to the word.
#unpre

= Primitives Provided =

#pre
is
is-data
is-macro
`
last
#unpre} 1177736642


#--------------------------------------------------
# ErrorCodes

page ErrorCodes {= E0 =
Nonfatal. This error is when a token can not be found in the dictionary
or converted to a number.

= E1 =
<b>Fatal</b>. This error is when the garbage collector fails to allocate enough
memory to fill a <b>[gc_alloc()|gc.c]</b> request.

= E2 =
Nonfatal. This error is given when an alien function (handled by the
[FFI]) is invoked with too many arguments for Toka to handle. You
shouldn't see it often.

= E3 =
Nonfatal. This error arises when a library can not be located for opening
by the [FFI]. 

= E4 =
Nonfatal. This error arises when a symbol can not be found in the
currently open library.

= E5 =
<b>Fatal</b>. When the return stack overflows or underflows, this error
is thrown and Toka exits.

Nonfatal. When the data stack overflows or underflows, this error is
thrown and Toka resets the stack pointer to the beginning of the stack.} 1177189326


#--------------------------------------------------
# errors.c

page errors.c {= Use =

This is where errors are handled. It does not export any functions
directly to Toka.

= Functions Provided =

#pre
error(long code)
Display a given error by code
#unpre

= Primitives Provided =

<i>None</i>

= See Also =

[ErrorCodes]} 1177189370


#--------------------------------------------------
# FFI

page FFI {To allow use of external libraries, Toka provides a simple <i>Foreign
Function Interface</i> (FFI). This is built around the following
primitives:

#pre
  from LIBRARY
#unpre

Set the import source to LIBRARY. This should be a fully-qualified
filename; it may require a path as well as the .so extension.

#pre
  N import FUNCTION
#unpre

Import FUNCTION from the previously specified library. A new quote named
FUNCTION will be created, and will take <i>N</i> arguments off the stack.
This function will always have a return value, even for <i>void</i>
functions.

You can also make use of <b>as</b> to rename the imported function.

#---
Example:

#pre
  #! Linux libc = libc.so.6, BSD libc = libc.so
  from libc.so.6
  2 import printf as printf.2
  " %i\n" 100 printf.2
#unpre

#---
The FFI is optional, and can be disabled at build time. Doing so reduces
the overall functionality of Toka, so doing this is only recommended if
you are using a system without dlopen()/dlsym(), or if you need more 
direct control over the functionality provided. To build a version of
Toka without the FFI, do:

#pre
  rm source/ffi.c
  make CFLAGS=-DNOFFI
#unpre

Again, <i>this is only recommended if your system does not support
dlopen()/dlsym()</i>.} 1177901033


#--------------------------------------------------
# ffi.c

page ffi.c {= Use =

Implements the [Foreign Function Interface|FFI], which allows use of external
libraries.

= Functions Provided =

#pre
Variables:
  void *library
  Pointer to the most recently opened library

ffi_invoke()
Call a foreign function. This translates between
Toka and CDECL calling conventions.

ffi_from()
Select a library to load from.

ffi_import()
Import and name an external function. This wraps
the imported function in a quote.

ffi_rename()
Rename the most recently defined word in the
dictionary.
#unpre

= Primitives Provided =

#pre
from
import
as
#unpre} 1176257909


#--------------------------------------------------
# Files

page Files {Toka provides functionality roughly identical to the standard C file I/O
functionality (fopen, fread, etc). 

#pre
  file.open  ( $m-n )  Open a specified file with
                       the specified mode.
  file.close ( n- )    Close the specified file handle
  file.read  ( nbl-r ) Read 'l' bytes into buffer 'b'
                       from file handle 'n'. Returns
                       the number of bytes read.
  file.write ( nbl-w ) Write 'l' bytes from buffer 'b'
                       to file handle 'n'. Returns
                       the number of bytes written.
  file.size  ( n-s )   Return the size (in bytes)
                       of the specified file.
  file.seek  ( nom-a ) Seek a new position in the
                       file. Valid modes are
                       START, CURRENT, and END. These
                       have values of 1, 2, and 3.
  file.pos   ( n-a )   Return a pointer to the current
                       offset into the file.
  file.slurp ( $-a )   Read file '$' into a new buffer.
  "R"        ( -x )    Mode for file.open
  "R+"       ( -x )    Mode for file.open
  "W"        ( -x )    Mode for file.open
  "W+"       ( -x )    Mode for file.open
  "A"        ( -x )    Mode for file.open
  "A+"       ( -x )    Mode for file.open
  START      ( -x )    Mode for file.seek
  CURRENT    ( -x )    Mode for file.seek
  END        ( -x )    Mode for file.seek
#unpre

= Examples =

#pre
  variable fid
  " /etc/motd" "R" file.open fid !
  fid @ file.size .
  fid @ file.close

  " /etc/motd" file.slurp [ type cr ] ifTrue
#unpre} 1177812690


#--------------------------------------------------
# files.c

page files.c {= Use =

Allows for reading and writing data to files.

= Functions Provided =

#pre
file_open()
Open a file using the specified mode. Modes are
a direct map to the fopen() modes: "r", "r+", "w",
"w+", "a", and "a+". Numeric values for these are
1 - 6, in that order.

file_close()
This is just a simple wrapper over fclose().

file_read()
This is just a simple wrapper over fread().

file_write()
This is just a simple wrapper over fwrite().

file_size()
This is just a simple wrapper over fstat() which
returns the size of the file.

file_seek()
This is just a simple wrapper over fseek().

file_pos()
This is just a simple wrapper over ftell().
#unpre

= Primitives Provided =

#pre
file.open
file.close
file.read
file.write
file.size
file.seek
file.pos
#unpre} 1175294463


#--------------------------------------------------
# First Steps

page {First Steps} {The following is a set of topical guides to various aspects of the Toka
language. It was written as the initial tutorial material, but as should
be evident, I am not a great writer of tutorials.

The material should be fairly easy for a moderately experienced
programmer to pick up. Easier still if one has experience with Forth,
Joy, Factor, or other stack-based languages. If you have no experience
with stack based languages, the [tutorial] may be helpful before you
start working through these sections.

#---

=== Introductory Bits ===
* [The Stack|UsingTheStack]
* [Basic Math|MathOperations]

=== Writing Functions ===
* [Quotes]
* [WordClasses]
* [Loops]
* [Conditionals]

=== Data Structures ===
* [Types]
* [Constants]
* [Variables]
* [Arrays]

=== Interfacing with the World ===
* [Files]
* [FFI]
* [Scripts]
* [Libraries]

=== Practical Matters ===
* [Commenting Code]
* [Stack Comments]} 1178750147


#--------------------------------------------------
# FloatsLibrary

page FloatsLibrary {This library adds support for floating point numbers and math. As with
many Forth implementations, it provides a separate stack for floating
point numbers, and alternative versions of the main stack and math words.
 
#pre
  float:    ( "-n )     Parse ahead for a new floating point
                        number
  fvariable ( "- )      Create a new floating-point variable
  f@        ( a-n )     Fetch the value in memory location 'a'
  f!        ( na- )     Store 'n' to memory location 'a'
  fdup      ( n-nn )    Duplicate the TOS
  fdrop     ( n- )      Drop the TOS
  fswap     ( ab-ba )   Exchange the TOS and NOS
  fdepth    ( -n )      Return the number of items on the stack
  fnip      ( xy-y )    Remove the second item on the stack
  frot      ( abc-bca ) Rotate top three values on stack
  f-rot     ( abc-acb ) Rotate top three values on stack twice
  fover     ( xy-xyx )  Put a copy of NOS above the TOS
  ftuck     ( xy-yxy )  Put a copy of TOS under NOS     
  f2dup     ( xy-xyxy ) Duplicate the top two items on the stack
  f2drop    ( xy- )     Drop TOS and NOS
  freset    ( *- )      Drop all items on the stack
  f+        ( ab-c )    Add TOS and NOS
  f-        ( ab-c )    Subtract TOS from NOS
  f*        ( ab-c )    Multiply TOS by NOS
  f/        ( ab-c )    Divide and get remainder
  :fstack   ( - )       Display all items on the float stack
  f.        ( n- )      Display the top item on the float stack
#unpre

=== Example ===

#pre
  needs floats
  float: 100
  float: 200.12
  f+
  f.
#unpre} 1178151284


#--------------------------------------------------
# garbage collector

page {garbage collector} {The Toka implementation makes heavy use of dynamically allocated memory.
To help avoid memory leaks, the memory allocation provides a very simple
form of <i>garbage collection</i>.

The model is very simple. A list containing pointers to each allocation,
and the corresponding size (in bytes) is kept. Each time memory is
requested, the code adds the request to the list. When the list is filled,
or if the allocation fails, the 16 oldest items are freed and all later
entries are shifted down.

Obviously there is also a way to mark entries as permanent. This is done
by <b>keep</b> (the <b>[gc_keep()|gc.c]</b> function). This routine skims
through the list of allocations (from most recent to oldest) looking for
a specific pointer. When found, that entry (and any subsequent
allocations -- in Toka these will almost always be subquotes, strings,
etc) are removed from the list.

In actual practice things are just a little more complex. Toka actually
maintains two lists; one for general allocations and a second one for
internal use. The second one is only used for allocations that are known
to be temporary. 

In addition, the code will always leave the 16 newest allocations in each
list alone to prevent them from falling out of scope.
 
Information regarding the current status of the garbage collection
subsystem can be obtained via <b>:gc</b> (the <b>[gc_info()|debug.c]</b> function).} 1176697195


#--------------------------------------------------
# gc.c

page gc.c {= Use =

Implements the memory allocator and basic [garbage collector].

= Functions Provided =

#pre
Variables:
  GCITEM gc_list[128]
  Holds the list of items marked as garbage

  long gc_depth
  A pointer to the top of the garbage collection
  list

  GCITEM gc_trash[128]
  Holds the short list of items marked as garbage

  long gc_tdepth
  A pointer to the top of the short garbage
  collection list

  long gc_used
  Contains the total size of all currently used
  memory, including permanent quotes.

  long gc_objects
  Contains the total number of objects that are
  currently existing, including permanent ones.

gc_alloc(long items, long size, long type)
Allocate the requested memory and add it to the
garbage collection list.
If type is set to 0, add to the normal garbage
collection list. If set to 1, add to the short
list of known garbage items which can be safely
freed at the next gc().
If the allocation fails, gc() is called, and the
allocation is retried. If it still fails, an
error is reported and Toka is terminated.

gc_keep()
Remove the specified address (and any childern it
has registered) from the garbage collection list.
If the TOS is not an allocated address, this will
silently ignore it.

gc()
Free the oldest allocations on the garbage list.
Will free up to 16 items from each list per
call. If there are 16 or less items remaining,
this code will leave the allocations alone.

toka_malloc()
Allocate TOS bytes of memory. Returns a pointer to
the allocated memory.
#unpre

= Primitives Provided =

#pre
keep
gc
malloc
#unpre} 1177180123


#--------------------------------------------------
# Home

page Home {Hello, and welcome to Toka!

Toka is an experimental language related to Forth. It is still under
development, and will continue to evolve over time. 

Don't expect your existing knowledge to apply directly to Toka. It allows
a good deal of low-level control, while supporting some useful
abstractions that make development easier. Some influences come from
RetroForth, HelFORTH, 4p, Factor, and SmallTalk.

<i>If you can't find something, try the [index]. A more structured set of
topics can be found in [First Steps].</i> 

= General Topics =

* [License]
* [Building] and [Installation]
* A [Tutorial] for new programmers
* [First Steps], a short guide to the language
* The [Words and Their Uses]

= Internals =

=== Topics ===

* Information about the [Ports]
* How the [garbage collector] works
* How the [parser] works
* Notes on the [threading model]
* Using [TokaDoc] to comment C code
* [ErrorCodes] that can arise
* [Limitations]

=== Source Files ===

* [bits.c]
* [class.c]
* [cmdline.c]
* [conditionals.c]
* [console.c]
* [data.c]
* [debug.c]
* [decompile.c]
* [dictionary.c]
* [errors.c]
* [ffi.c]
* [files.c]
* [gc.c]
* [initial.c]
* [interpret.c]
* [math.c]
* [parser.c]
* [quotes.c]
* [stack.c]
* [toka.c]
* [vm.c]} 1178750209


#--------------------------------------------------
# Index

page Index {[@pageIndex@]} 1026586734


#--------------------------------------------------
# initial.c

page initial.c {= Use =

Build the initial dictionary

= Functions Provided =

#pre
build_dictionary()
Attach names and classes to the various initial
words in the Toka language.
#unpre

= Primitives Provided =

<i>None</i>} 1175294584


#--------------------------------------------------
# Installation

page Installation {To get the most out of Toka, it needs to be installed. This can be done
via the build system:

#pre
  make install
#unpre

When done this way, the following files are installed:

#pre
  /usr/bin/toka
  /usr/share/toka/bootstrap.toka
#unpre

After installation, run the test suite:

#pre
  make tests
#unpre

Look for any failures in the test.log. If you encounter a problem, please
forward the test.log to charles.childers@gmail.com along with some
basic information about your system (OS, CPU type, GCC version, Toka
revision #)} 1177366737


#--------------------------------------------------
# interpret.c

page interpret.c {= Use =

The interpreter itself.

= Functions Provided =

#pre
Variables:
  long compiler
  When set to 0, interpret; when set to -1, 
  compile. This is checked by the various word
  classes defined in class.c

  char *scratch
  Temporary holding area used by the parser and
  other routines.

  char *tib
  Pointer to the text input buffer.

count()
Perform strlen() on the string passed on TOS. This
returns the string and the count on the stack. The
count is increased by 1 to include the trailing 
ASCII 0.

interpret()
Accept and process input.
#unpre

= Primitives Provided =

#pre
compiler
count
#unpre} 1177177233


#--------------------------------------------------
# Lesson 0

page {Lesson 0} {= Why Bother? =

Toka is weird compared to most popular computer languages. Until you
learn how, it is hard to read because it is not based on the syntax of
algebraic expressions.

But it is worth learning because a running Toka system gives you an
extraordinary degree of low-level control over the system. Unlike most
other programming environments that put up walls to hide or block access
to "unauthorized" things, Toka makes it easy to get at anything, at any
level from low to high.

= Toka Syntax =

Here is syntactically-valid line of Toka code: 

#pre
 this is a test 123 456
#unpre

Don't try to guess what it does; in fact it doesn't necessarily actually
work, because some of the symbols might not be defined. But it is
syntactically valid. It consists of 6 words, "this" "is" "a" "test" "123"
"456". Words are separated by white space - spaces, tabs, and newlines.
In most cases, spaces and newlines are the same.

Another syntactically valid line: 

#pre
 asdf  foo  jello  @W#$%^,T/%$  1a2qw2   gibbet
#unpre

That's 6 words. One of them is pretty strange, consisting mostly of
punctuation, but it is a word nevertheless. Any string of printing
characters is a word. Toka limits word names to 255 characters.
 
= Left to Right Execution =

The Toka interpreter is very simple. It parses the next word (i.e. it
skips whitespace, then collects characters until it sees another
whitespace character) and executes it.

That is it in a nutshell. So if you are trying to understand a Toka
program in detail, you have to look at each word in turn and work out
what it does. That sounds simple, but it will trip you up if you insist
on looking for algebra. Just go left to right, one word at a time.

With practice, you will learn enough of the Toka vocabulary (the meanings
of standard words) so that you can see what is going on at a glance,
without having to puzzle out each individual word. It is just like
learning to read - it is tedious until you get the basic vocabulary down,
then it is easy. 

<i>Thus endeth the lesson.</i>} 1178666311


#--------------------------------------------------
# Lesson 1

page {Lesson 1} {= Review =

In the previous lesson we learned that: 
* The top-level parser only looks for whitespace, so Forth words must be
  separated by one or more spaces
* Execution proceeds from left to right. Get a word, execute it. 

Today we will start trying some commands. 

= The Stack =

Toka has an explicitly visible stack that is used to pass numbers between
words (commands). Using Toka effectively requires you to think in terms
of the stack. That can be hard at first, but as with anything, it becomes
much easier with practice.

Toka also has a secondary stack - the "return stack" - that is used for
return addresses and a few other things. Toka automatically manages the
return stack so you don't have to think about it for the most part (but
you can get at it if you need to; Toka doesn't block you from doing
anything). 

== Displaying the Stack ==

#pre
  :stack
#unpre

Doing this will cause Toka to show you what is on the stack. If the stack
contained the numbers 5678 and 112233, you would see:

#pre
 <2> 5678 112233
#unpre

The number to the right is the top of the stack and the number in
brackets on the left is the number of items on the stack. 

== Putting Numbers on the Stack ==

If you type a number, it gets pushed onto the stack: 
#pre
 12345 998877
 :stack
 <2> 12345 998877
#unpre

What we see here is that the two numbers did get pushed onto the stack,
and since <b>:stack</b> was called, the stack contents were displayed.

= First Words =

#pre
 12345 998877 + :stack
 <1> 1011222
#unpre

The <b>+</b> word pops two numbers from the stack, adds them, and pushes
the sum back on the stack. Note that: 

* + doesn't display the result, it just pushes the result back on the stack. In this case, however, we are assuming that "showstack" mode is on, so the interpreter displayed the stack for us automatically before the next prompt. 
* The numbers are in decimal. Toka can operate in bases 2, 8, 10, and 16,
  however it can not display binary numbers at present. The default base
  is decimal. You can change the base at any time by typing <b>hex</b> or
  <b>decimal</b>. All of the examples in this tutorial series will use
  decimal as the default base.
* The current number base applies to both number input and number output. 

= Displaying Numbers =

#pre
 12345
#unpre

Now the number is on the stack. It can be displayed:

#pre
 :stack
 <1> 12345
 :stack
 <1> 12345
#unpre

<b>:stack displays the entire stack, non-destructively. 

#pre
 12345
 .
 12345
 :stack
 <0>
#unpre

<b>.</b> pops the top of the stack and displays that number. Afterwards,
the number is no longer there.


= How the Interpreter Works =

The Toka interpreter is very simple. It just does this over and over: 

* Read a line of input 
* While there is more data in the line: 
* Parse a whitespace-delimited word 
* Lookup the word in a list of defined words. If found, execute the code
  for that word. 
* Otherwise, try to interpret the word as a number in the current number
  base. If so, push it on the stack. 
* Otherwise display an error message 

<i>Thus endeth the lesson.</i>} 1178666959


#--------------------------------------------------
# Lesson 2

page {Lesson 2} {= Review =

In the previous lesson we learned to: 

* Display the stack with <b>:stack</b> 
* Push numbers on the stack by typing them 
* Control the number base with <b>hex</b> and <b>decimal</b> 
* Execute words by typing their names 

= Stack Diagrams =

Pay attention to this section because it introduces notation that will be
used over and over.

Since Toka words use the stack for arguments and results, their
description must tell you the arguments that they pop from the stack and
the results that they push back on the stack. That is done with a <i>stack
diagram</i>.

#pre
 +  ( n1 n2 -- n3 )
#unpre

That indicates that the Toka word <b>+</b>, which we saw in the last lesson,
pops two numbers n1 and n2 from the stack and pushes back one number n3.
The list of items before the "--" is the arguments, the list after is the
results. In each list, the items at the right is the top of the stack.

In general, Toka words can take any number of arguments and leave any
number of results.

This is purely a notation convention. The Toka interpreter does not
process stack diagrams other than to skip them. The way it knows to skip
them is because the Toka word <b>(</b> introduces a comment, which is
terminated by the next <b>)</b>. 

Another example:

#pre 
 :stack  ( -- )
#unpre

That means that <b>:stack</b> has no net stack effect. It doesn't pop
anything off the stack (no arguments) and it doesn't leave any extra
items on the stack after it finishes. It might push and pop numbers while
it is executing, but when it is done, the stack is the same as it was
before.

#pre 
 .  ( n -- )
#unpre

The word <b>.</b> (which displays a number), pops its one argument from the
stack and leaves nothing in its place.

The names in the argument and result lists (e.g. "n1", "n2", "n3") are
arbitrary, but as an aid to understanding, they are often chosen to
convey extra information. For example: 

#pre
 type  ( adr -- )
#unpre

We haven't seen the word <b>type</b> yet, but clearly it takes one
argument, an address. It pops the argument from the stack, leaving
nothing in its place. 

Conventionally, stack item names beginning with "n" refer to signed
integers, "u" to unsigned integers, "d" to double numbers (two stack
numbers interpreted as a 64-bit integer), "adr" to addresses, "flag" to
values that are either true (0xfffffff) or false (0). But that is not a
hard and fast rule.

Toka also has a shorter form of stack comments that is often used. See
[Stack Comments] for further details on the short form.

= How Comments Work =

The following is in some sense an implementation detail, but it's good to
understand it, because it is key to Toka's approach to syntax, which is
vastly different to most other languages.

In the section above I mentioned that the word <b>(</b> skips to the next
<b>)</b>. That might seem like an exception to the rule that the
interpreter only parses whitespace-delimited words, but it is not.

What actually happens is that the main interpreter loop only sees the
<b>(</b>. The <b>(</b> must be followed by whitespace, otherwise the
interpreter will not parse just </b>(</b> but rather some longer string
beginning with </b>(</b>. The interpreter then looks in the list of
defined words for one named <b>(</b>, and executes it.

The behavior of the <b>(</b> word is to call the parser, asking it to collect a sequence of characters delimited by <b>)</b>, and then to discard the result. So
Any word can call the input parser, not just the main interpreter.

The parser itself can use any character as a delimiter, not just
whitespace. The main interpreter only asks the parser for
whitespace-delimited words, but other words can and do parse using other
delimiters.

This same approach (main interpreter calls a word that then parses using
a different delimiter) is also used for string literals where the
delimiter is <b>"</b>. 

You can, if you wish, call the parser yourself from user code, to collect
any kind of string you want. It's best to use this capability sparingly
to avoid confusion, but it illustrates the fact that the entire Toka
system is available to you; nothing is magic or hidden.

= Comment to End of Line =

The <b>( .... )</b> comment form stops at the <b>)</b>; stuff after it will be interpreted as usual. To comment out everything else on the line, use <b>#!</b>. 

#pre
 #! everything after the first #! will be ignored
#unpre

Note that the <b>#!</b> must be followed by whitespace, because <b>#!</b>
is just a word like anything else. The way that <b>#!</b> works is to
call the parser with a delimiter value (10) that matches a line ending
character, discarding the result. The parser will stop at the end of the
line, having found the delimiter. 

<i>Thus endeth the lesson</i>} 1178668132


#--------------------------------------------------
# Lesson 3

page {Lesson 3} {= Review =

In the previous lesson we learned that: 
* Toka words are described by stack diagrams like: ( argn .. arg0 --
  resultm .. result0 ) 
* Comments are either <b>( this is a comment )</b> or <b>#! the rest of the line is a comment</b>
* Both <b>(</b> and <b>#!</b> must be followed by whitespace 
* Comments work by executing a word that then explicitly calls the input parser 

= Arithmetic and Logical Operators =

We have already seen <b>+</b>, which pops two numbers, adds them, and
pushes the result. Here are some more numeric operators with their stack
diagrams:

#pre
 +       ( n1 n2 -- n1+n2 )
 -       ( n1 n2 -- n1-n2 )
 *       ( n1 n2 -- n1*n2 )   \ Signed multiplication
 /       ( n1 n2 -- n1/n2 )   \ Signed division
 mod     ( n1 n2 -- n1%n2 )
 /mod    ( n1 n2 -- n1%n2 n1/n2 )
 and     ( n1 n2 -- n1&n2 )
 or      ( n1 n2 -- n1|n2 )
 xor     ( n1 n2 -- n1^n2 )
 <<      ( n1 n2 -- n1<<n2 )  \ Shift bits left
 >>      ( n1 n2 -- n1>>n2 )  \ Shift bits right
 not     ( n -- ~n )          \ Bitwise logical inversion
 negate  ( n -- -n )          \ Arithmetic negation, i.e. 0-n
 1-      ( n -- n-1 )         \ Decrement by 1
 1+      ( n -- n+1 )         \ Increment by 1  
#unpre

All of the above operators work on integers of the natural size for the
machine (32 bits on 32-bit processors). 

= Using Toka as a Calculator =

Armed with those operators, plus the <b>.</b> (pop and display) word that
we have already seen, we can use Toka as an integer calculator. But since
everything is stack based, we have to use Reverse Polish instead of
algebraic syntax. Instead of writing down an algebraic expression with
parentheses to control the grouping, we have to think about what to do
first, and then do it.

So, suppose that we want to calculate ( 5 + ( 4 * 7 ) ). The
multiplication has to be done first, before we can add the 5. We could
perform that calculation in Toka with:

#pre
 4 7 * 5 + .
#unpre

Breaking this down into the individual steps, 

* push 4 on the stack 
* push 7 on the stack 
* pop two items from the stack, multiply them, and push the result (28)
  back on the stack 
* push 5 on the stack 
* pop two items from the stack, add them, and push the result (33) back
  on the stack
* pop the stack and display it 

The same calculation can be written in a different way 

#pre
 5 4 7 * + .
#unpre

In this version, we push all three numbers onto the stack at once, then
perform the arithmetic - first the multiplication of 4 and 7, and finally
the addition of 5 to the product.

The key to using RPN is that you have to think in terms of doing steps in
order instead of writing a picture of the algebraic expression and
letting the compiler sort it out.

= Stack Operators =

Sometimes you need to copy or rearrange the stack to bring items to the
correct position for further use. Four basic stack operators get the most
use. 

#pre
 dup  ( a -- a a )
 drop ( a -- )
 swap ( a b -- b a )
 over ( a b -- a b a )
#unpre

Stack operators will be examined in more detail in a later lesson. 
 
<i>Thus endeth the lesson</i>} 1178668498


#--------------------------------------------------
# Lesson 4

page {Lesson 4} {= Review =

In the previous lesson we learned that: 

* Forth has the usual collection of integer arithmetic and logical operators 
* You have to do calculations in postfix (Reverse Polish) form 

= Making New Words =

So far we have done everything interactively, using only numbers and
predefined words - and only a miniscule fraction of the predefined words
that exist. Now we will learn how to make our own new words.

Suppose that we want to add 12345 to several other numbers and display
the results. Using just what we have learned so far, we could write:

#pre
 55 12345 + .
 12400
 2442 12345 + .
 14787
#unpre

and so on. This wouldn't even be particularly tedious if you use a tool
like <i>rlwrap</i> to provide command line history and editing. But we
want to learn to make new words, so we will.

#pre
 [ 12345 + . ] is foo
 55 foo
 12400
 2442 foo
 14787
#unpre

We made a new word "foo" whose behavior is the same as "12345 + ." . Now
"foo" can be used just the same as any other word in the system. Here's
how the process works:

The Toka word <b>&lb;</b> (which must be followed by whitespace, just like
every other word) creates a new <i>quote</i> and sets the interpreter to
<i>compile state</i> (normally the interpreter is in <i>interpret
state</i>). In compile state, instead of executing each word that it
encounters, the interpreter compiles the behavior of the encountered word
into the body of the new word. When it sees a number in compile state,
the interpreter compiles code that will push that number on the stack
when the new word later executes. When the interpreter encounters
<b>&rb;</b>, it compiles something akin to "return from subroutine" and
switches back to interpret state. The word <b>is</b> parses for a
whitespace delimited token and creates a new name using this token and
attaches the quote to it.

What about arguments and results? Well, since the stack is used for
passing arguments, everything just works. The <b>+</b> that is compiled
inside "foo" can pop two numbers off the stack (e.g. the "55" that was
pushed outside of foo, and the "12345" that was pushed earlier during the
execution of foo), in the same way as it would if you executed "+"
directly from the interpreter.

But wait, you say, what about the return address that is necessary to get
back when foo executes? Doesn't that go on the stack, and thus interfere
with the numbers? No, because a separate stack (the "return stack") is
used for return addresses. 

= Compiled Code =

What does the compiled code (inside the new word "foo") look like? Well,
the Toka language doesn't specify that. It just says that the result of
executing "foo" has to be the same as if you executed its constituent
words. Different Toka implementations can use different code generation
strategies. Some may generate optimized machine language code. Others
may generate machine language code that consists of a sequence of subroutine
calls, one call to each constituent word. Perhaps the most common
approach is "threaded code", in which the body of "foo" consists of an
array of addresses, one for each constituent. A tiny "tree walker"
machine language code sequence grabs each address in turn and jumps to
it. Each approach has its advantages and disadvantages. Threaded code
offers a good balance between speed, compactness, simplicity,
portability, and ease of debugging. 

= Redefinitions =

What happens if you try to make a new word that has the same name as an
existing one? Perhaps surprisingly, Toka will let you do that. Consider:

#Pre
 [ 5678 . ] is word1
 word1
 5678
 [ word1 123 . ] is word2
 word2
 5678 123
 [ 999 . ] is word1 
 word1
 999
 word2
 5678 123
#unpre

Whoa! This is weird! Or is it? 

First we create "word1" that displays "5678". Then we create "word2" that
calls "word1" then displays "123". So far so obvious.

Now we create "word1" again. Now when we interpret "word1" we see "999"
instead of "5678". But when we interpret "word2", it still shows "5678".

What has happened is that the both definitions of "word1" exist in the
system, as separate chunks of code that happen to have the same name.
"word2" still calls the first one - the only one that existed when
"word2" was compiled (early binding). But the interactive interpreter
sees that most recent one, because the search for defined words starts
with later definitions and stops when it gets a match.

Recursion and Chaining 

This next topic is perhaps a bit too advanced for this stage of the
lesson series, but I'm including it anyway because I know that some
readers will wonder about it...

Okay, what happens if you try to use the word "xyz" inside the definition
of "xyz"? The question is especially interesting in light of the fact
that you can have multiple definitions with the same name. You might
reasonably want a new definition to "xyz" to call a previous version of
"xyz" and then extend its behavior. You might also reasonably want
recursion. And in fact, you can do either.

#pre
 [ dup 1 > [ dup 1- recurse * ] ifTrue ] is factorial
 5 factorial .
 120
#unpre

Don't worry about the words you don't yet know. Just notice that
"factorial" calls "factorial" recursively, which works because we used
<b>recurse</b> inside the definition.

Now let's look at the other possibility, in which we want a new
definition to call and extend an existing definition of the same name: 

#pre
 [ 111 . ] is init
 init
 111

 [ init 222 . ] is init
 init
 111 222
 
 [ 0 . init ] is init
 init
 0 111 222

Here we have created a word "init" that displays the number 111, then we
made a new word of the same name that calls the old one and also displays
"222", and finally we made a third one that first displays "0", then
calls the second one (which still calls the first one). It works because
the name of each successive redefinition is hidden until complete, so the
interpreter/compiler finds the previous one during the compilation of the
new one.

Clearly, you should use this redefinition thing sparingly, lest confusion
reign, but there are situations where this sort of thing can be extremely
useful. It's especially nice for initialization sequences where each
module can just add its own init code to whatever is already there.

The reason I'm explaining how all this works is because, unlike most
other languages, Toka gives the programmer explicit access to the same
machinery that the compiler uses. This, perhaps more than any other
feature, is what makes Toka so powerful with such a small memory
footprint. (LISP is similar in that respect.) Since the machinery is an
integral part of the proposition, you have to understand the basics of
how it works.

= Stack Comments, Reprised =

So far I have just been tossing out new definitions willy-nilly, without
any documentation. That is fine when you are just fooling around
interactively, experimenting. But, of course, when you are writing
"keepers", source code that you want to save in a file, you need some
documentation. The minimum documentation is a stack diagram. If I were to
save the previous recursive definition of factorial in a file, I would
probably write:

#pre
 [ ( n -- n! )
   dup 1 > [ dup 1- recurse * ] ifTrue
 ] is factorial
#unpre

The stack diagram "( n -- n! )" indicates that there is one argument and
one result. For this example, that would probably be enough, since
factorial is a well-known mathematical function and the name is pretty
clear. If the intent of the new word were not so obvious, I would have
added a line or two of commentary (beginning with "#!") before the
definition. 

<i>Thus endeth the lesson</i>} 1178672803


#--------------------------------------------------
# Lesson 5

page {Lesson 5} {= Data =

There are several ways to store and retrieve data values. 

== Variables ==

#pre
 variable myvar
#unpre

"variable" defines a new word (parsing the new word name from the input
stream, as with ":") and allocates enough data space for a number (e.g.
32-bits). When you later execute the new word ("myvar" in this case), it
pushes the address of that data area. The stack diagram for the new word
is "( -- adr )". The initial contents of the data is undefined.

You can put data into the variable with: 

#pre
 12345 myvar !
#unpre

"!" is pronunced "store". Its stack diagram is "( n adr -- )".

To get the data back, use 

#pre
 myvar @ .
 12345
 555 mvar !
 myvar @ .
 555
#unpre

"@" is pronounced "fetch". Its stack diagram is "( adr -- n )". Note
that, after the example above, the data value is on top of the stack. To
display it, you would need to say "." afterwards (unless "showstack" mode
is on).

== Other Memory Access Operators ==

The size of the number that "variable", "@", and "!" use is the "natural"
size for the implementation, similar to "long int" in C.

"@" and "!" are not limited to addresses returned by variables; they can
be used with arbitrary memory addresses. However, for externally-defined
data, it is usually a good idea to use memory access operators that
explicitly specify the data size.

#pre
 c@  ( adr -- b )    \ Fetch a 8-bit value
 c!  ( b adr -- )    \ Store a 8-bit value
#unpre

== Constants ==

Suppose you need a Toka word that returns (i.e. pushes on the stack) a
single numeric value. You could do that with a quote, as in:

#pre
 [ 12345 ] is mynum
#unpre

However, constants are important enough that Toka allows defining them as
a data element:

#pre
 12345 is-data mynum
#unpre

Functionally, the two different definitions of "mynum" are equivalent,
but the <b>is-data</b> definition will execute faster and occupy less
space.

When you are writing code in a file for saving, it is a good idea to
specify the number base explicitly, instead of assuming a particular
value (e.g. hex or decimal) for the current number base. So in a file I
would write:

#pre
 decimal 12345 is-data mynum
#unpre

or 

#pre
 hex 1a234f is-data mynum
#unpre

== Efficiency of Constants ==

When a constant created with <b>is-data</b> is used in a quote, the
resulting code is a bit different than when the constant is created as a
quote. Specifically, comparing:

#pre
 1234 is-data foo
 [ foo + ] is add-foo
 ` add-foo :see
#unpre

to 

#pre
 [ 1234 ] is foo
 [ foo + ] is add-foo
 ` add-foo :see
#unpre

When using <b>is-data</b>, the resulting value is inserted directly into
the quote. This saves the overhead of calling the function at runtime.} 1178750058


#--------------------------------------------------
# Libraries

page Libraries {Toka has an optional set of external libraries that allow significantly
more functionality. These are not included with a standard Toka
distribution and can be obtained at:

#pre
  http://code.google.com/p/toka-library
#unpre

Libraries can be loaded with <b>needs</b>. For example, to load the
<i>strings</i> library (if installed), do:

#pre
  needs strings
#unpre

A master library, <i>everything</i>, is provided to import all current
libraries. This makes it easy to access all provided functionality in any
project. To make use of this, use this at the start of a program:

#pre
  needs everything
#unpre

=== Library Documentation ===

Each library module contains some documentation at the start of its code.
A few of the more significant library modules are documented here for
your use.

* [StringsLibrary] 
* [TimeLibrary]
* [MathLibrary] 
* [SocketLibrary]
* [ShellLibrary]
* [FloatsLibrary]} 1178150659


#--------------------------------------------------
# License

page License {Toka is Copyright (c) 2007 Charles R. Childers


Permission is hereby granted, free of charge, to any person obtaining a copy 
of this software and associated documentation files (the "Software"), to deal 
in the Software without restriction, including without limitation the rights 
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell 
copies of the Software, and to permit persons to whom the Software is furnished 
to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in 
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
IN THE SOFTWARE.} 1175645279


#--------------------------------------------------
# Limitations

page Limitations {* Cell size is machine dependent, generally 32 bits (4 bytes) or 64 bits
  (8 bytes) in size. <b>cell-size</b> returns the actual size in bytes.
* Character size is machine and OS dependent.  Normally 8 bits (1 byte).
  <b>char-size</b> returns the actual size in bytes.
* Quotes can be up to 64 elements (values, primitives, embedded quotes,
  calls to other quotes, string pointers, etc) in length.
* The data stack can hold up to 100 cells.
* The return stack can hold up to 1024 cells.} 1178430367


#--------------------------------------------------
# Loops

page Loops {Toka provides a limited collection of primitives for building various
types of simple loops.

The most basic form is <b>iterate</b>, which takes the following form:

#pre
  number-of-iterations quote  iterate
#unpre

<b>iterate</b> will invoke <i>quote</i> the specified number of times.
With <b>iterate</b>, the count goes down from N to 1, with 1 being the
last cycle of the loop. To count up from 1 to N instead, use
<b>+iterate</b>. Other than this, both of these words take the same form.
Some examples:

#pre
  10 [ i . ] iterate
  10 [ i . ] +iterate
#unpre

Note the use of <b>i</b>, the loop index. When looping via <b>iterate</b>
and <b>+iterate</b>, the loop index is set to the current cycle number.
<i>Other types of loops do not set the loop index.</i> 

The other type of loop is a <b>whileTrue</b> or <b>whileFalse</b> loop.
The normal form:

#pre
  quote whileTrue
  quote whileFalse
#unpre

Each time <i>quote</i> is invoked, a value of <b>TRUE</b> or <b>FALSE</b>
should be left on the stack. The loop primitives will consume this, and
either repeat the loop or end the loop until the condition is not met.
<b>whileTrue</b> continues execution if the returned value is <b>TRUE</b>;
<b>whileFalse</b> continues if the returned value is <b>FALSE</b>.

Some examples:

#pre
  1 [ dup . 1 + dup 101 < ] whileTrue
  101 [ dup . 1 - dup 1 < ] whileFalse
#unpre} 1177019422


#--------------------------------------------------
# math.c

page math.c {= Use =

Basic math operations on the stack.

= Functions Provided =

#pre
add()
Add TOS to NOS

subtract()
Subtract TOS from NOS

multiply()
Multiply TOS by NOS

divmod()
Divide and return the result, including remainder
#unpre

= Primitives Provided =

#pre
+
-
*
/mod
#unpre} 1175294665


#--------------------------------------------------
# MathLibrary

page MathLibrary {This library extends the core math functionality of Toka in minor ways. 

The provided API follows:

#pre
     abs
     ( n-n )
     Returns the absolute value of 'n'

     random
     ( -n )
     Returns a random number

     srandom
     ( s-x )
     Set a new seed for the random number generator

     ^
     ( xy-z )
     Returns x^y power

     sqrt
     ( x-y )
     Returns the square root of x

     sqrt-closer
     Used internally by sqrt
#unpre} 1177901677


#--------------------------------------------------
# MathOperations

page MathOperations {Toka provides a very basic set of math functionality, sufficient for many
purposes. The functions are:

#pre
  +        ( ab-c )    Add TOS and NOS
  -        ( ab-c )    Subtract TOS from NOS
  *        ( ab-c )    Multiply TOS by NOS
  /mod     ( ab-cd )   Divide and get remainder
#unpre

In addition, the standard bootstrap adds some additional operations:

#pre
  1+       ( x-y )     Increase value on stack by 1
  1-       ( x-y )     Decrease value on stack by 1
  negate   ( x-y )     Invert the sign of TOS
  /        ( xy-z )    Divide two numbers
  mod      ( xy-z )    Divide two numbers and get remainder
  not      ( x-y )     Invert the value 'x'
  */       ( abc-d )   (a*b)/c
#unpre} 1177020107


#--------------------------------------------------
# New Pages

page {New Pages} {To create a new page,

* Add a link to it in this page (or on any other page where the link would
  be more appropriate):
** Press the "Edit" button.
** Go to the bottom of the page (or anywhere, really).
** Type the page's name in square brackets, &lb;Like This&rb;.
** Press the "Done" button.
* Click on the link.
* On the Status Line, down at the bottom of the window, Notebook will ask
  if you want to create the page.  Type "yes" or "y", and press Enter.

<h>New Pages</h>

* [Tour]
* [Sandbox]} 1102291321


#--------------------------------------------------
# parser

page parser {Toka's parser is fairly simple. It only handles input coming from a
<i>file stream</i> (which includes <i>stdin</i>). Input sources are
implemented as a stack.

At the bottom is the <i>stdin</i> file. Generally on startup, the
<i>bootstrap.toka</i>. A script would be at the third position, and any
files that includes get added above it.

The parser will read from the top file until either <b>end.</b> or an EOF
(end of file) is detected. At this point, it closes the file and drops to
the next one on the stack.

Internally, the fundamental function for parsing is <b>get_token()</b>.
This accepts two arguments, a pointer to a buffer to place the resulting
string, and a delimiter character. Parsing ends when the delimiter
character is encountered. <b>get_token()</b> also leaves a pointer to the
resulting token on the stack. A Toka-level wrapper, <b>parse()</b>, makes
use of <b>get_token()</b>.

When parsing, a number of <i>escape sequences</i> are recognized. These
are listed below:

#pre
  \n
  Embed a carriage return (ASCII 10) into the token
 
  \r
  Embed a line feed (ASCII 13) into the token

  \^
  Embed ASCII 27 into the token. Useful with VT100/ANSI terminal
  escape sequences

  \\
  Embed a \ character into the token

  \"
  Embed a quote into the token
#unpre

Processing of escape sequences can be enabled or disabled by turning the
<b>escape-sequences</b> variable <b>on</b> or <b>off</b>. For example:

#pre
  escape-sequences off
  " \\ hello \\" type cr
  escape-sequences on
  " \\ hello \\" type cr
#unpre


=== Tips ===
* Tokens have a maximum size of 4096 characters
* If the delimiter = 10, <b>get_token()</b> will also break on
  encountering ASCII 13.
* If the delimiter = 32, <b>get_token()</b> will also break on
  encountering ASCII 10 or ASCII 13.} 1177990380


#--------------------------------------------------
# parser.c

page parser.c {= Use =

Implement the [parser].

= Functions Provided =

#pre
Variables:
  FILE *input[]
  Current file stream to parse from. Setup as
  an array of 8 inputs.

  long isp
  Pointer to the most recent input source in the array

  long base
  Holds the current numeric base

  long parser
  When ON (TRUE), system parsing words will parse. When
  OFF (FALSE), they will take a string from the stack.

to_number()
Attempt to convert a string (on TOS) to a number.
This accepts a format of:
  [-]number
If successful, it leaves the number and a flag of
-1 on the stack. Otherwise, it leaves the original
string, and a flag of 0.

parse()
Parse the input buffer until the character passed
on TOS is found, or until the end of the line is
encountered. Return a pointer to the resulting
string on the stack.

get_token(char *s, long delim)
Return a string (in "s") up to the specified 
delimiter. This also puts the resulting string 
on the stack.

long include_file(char *s)
Attempt to open a file ("s") and add it to the
top of the input stack.

include()
Take a filename off the stack, attempt to open
it and add it to the input stream if successful.

needs()
Take a filename off the stack. Attempt to open it
from the library, and add it to the input stream 
if successful.

force_eof()
Remove the current file from the input stack. This
can be used to abort an include.
#unpre

= Primitives Provided =

#pre
>number
parser
parse
include
needs
end.
#unpre} 1178016664


#--------------------------------------------------
# Ports

page Ports {This page lists the officially supported platforms and includes notes on
building for specific targets.

#---
= Quick Summary =

CPUs: x86, x86-64, ARM, MIPS, Itanium

OSes: Linux, NetBSD, FreeBSD, OpenBSD, DragonFly BSD, BeOS, Cygwin, OpenSolaris

#---
= Linux =

Supported CPUs: x86, x86-64, MIPS, Itanium

Toka has been built and tested on Debian and SuSE, using
GCC versions 2.95, 3.0, 3.1, and 4.1

#---
= BSD =

=== OpenBSD ===

Supported CPUs: x86, ARM

=== FreeBSD 4.x - 6.x ===

Supported CPUs: x86

=== NetBSD 3 ===

Supported CPUs: x86, MIPS, ARM

=== DragonFly BSD ===

Supported CPUs: x86

#---
= BeOS =

Supported CPUs: x86

Requires libdl.so (from http://bebits.com/app/2917)

You may also need (or want) to use the newer GCC from
http://bebits.com/app/4011

Build with <b>CFLAGS=-I/beos/develop/headers</b>

#---
= Cygwin =

Supported CPUs: x86

Toka has been built and run under Cygwin on both Windows XP and Windows
Vista. This port is not officially supported, and may be buggy,
especially when using the FFI.

#---
= OpenSolaris =

Supported CPUs: x86

Only tested under Nexenta GNU/Solaris distribution} 1178750601


#--------------------------------------------------
# Quotes

page Quotes {With the functions described above, many small programs can be written.
Toka has much more functionality, but before proceeding further, we need
to take a look at how to create new functions (called <i>quotes</i>).

In Toka, a <i>quote</i> is the basic building block. At the simplest
level, they are anonymous blocks of code and data. Quotes are created by
encolsing the code and/or data in brackets:

#pre
  [ ]
#unpre

The above will create an empty quote and leave a pointer to it on the
stack. You can attach a name to this pointer with <b>is</b>:

#pre
  [ ] is empty-quote
#unpre

Names can include any characters, other than space, tab, cr, or lf (enter
key). (<i>There are other forms of <b>is</b>, but this is the most common
one; the others are discussed [elsewhere|WordClasses]</i>).} 1177465671


#--------------------------------------------------
# quotes.c

page quotes.c {= Use =

Build, operate on quotes.

= Functions Provided =

#pre
Variables:
  QUOTE quotes[8]
  Holds details about the compiler state, heap,
  etc for quotes during compilation.

  long qdepth
  Tracks how deeply the quotes are nested

  long quote_counter
  Tracks the current loop index

  Inst top
  Holds a pointer to the root quote

begin_quote()
Create a new quote. This allocates space for it,
and sets the compiler flag. A pointer to the
quote's start is pushed to the stack.

end_quote()
Terminate the previously opened quote and perform
data_class() semantics.

invoke()
Call a quote (passed on TOS)

compile()
Compile the code needed to call a quote (passed on TOS)

iterate()
Repeat execution of a quote (passed on TOS), NOS
number of times.

alt_iterate()
Repeat execution of a quote (passed on TOS), NOS
number of times.

truefalse()
Takes three items (true-xt, false-xt, and a flag)
from the stack. Stack should be passed in as:
  flag true false 
It will execute true if the flag is true, false
otherwise.

recurse()
Compiles a call to the top-level quote. As a
trivial example:
  [ dup 1 > [ dup 1 - recurse swap 2 - recurse + ] ifTrue ] is fib

qlit()
Push the value in the following memory location
to the stack. This is used instead of lit() so
that the decompiler (and eventually debugger) can
reliably identify nested quotes as opposed to 
regular literals.

quote_index()
Return the current loop index (counter)

quote_while_true()
Return execution of a quote until the quote
returns FALSE.

quote_while_false()
Return execution of a quote until the quote
returns TRUE.
#unpre

= Primitives Provided =

#pre
[
]
recurse
i
whileTrue
whileFalse
compile
invoke
iterate
+iterate
ifTrueFalse
#unpre} 1178881760


#--------------------------------------------------
# Recent Changes

page {Recent Changes} {[@recentChanges@]} 1026585675


#--------------------------------------------------
# Sandbox

page Sandbox {This is place to experiment with Notebook's way of marking up text.
Edit this page to see how you type things; then save it to see what it looks
like when you're browsing.

= You Can Have Section Headers =

*	You can have bulleted lists.
*	You can type <b>bold</b>, <i>italic</i>, and <m>monospace</m> text,
	or any combination.
*   You can have <h>inline header text</h>.
*	You can have <s>very small</s> text.
*   You can <x>strike things out</x>.

:	You can simply indent a paragraph without adding a bullet.

Paragraphs end with the first blank line, bullet item, or indented line.
No matter how many lines long a paragraph is, Notebook will wrap it for
display so that it looks nice.

 If you leave a space character at the beginning of a paragraph, the whole
 paragraph is "Preformatted".  That means that it's displayed in a monospace
 font, exactly as is.  It's conventional to put whitespace at the beginning of
 every line of a preformatted paragraph, but that's not necessary.

Preformatted text is useful for typing in tables and things like that.} 1113419698


#--------------------------------------------------
# Scripts

page Scripts {Toka can be used to write scripts. Start your code with the following:

#pre
  #! /usr/bin/toka
#unpre

And set the permissions to executable (<i>+x</i>), and you can run your
code directly at the command line (assuming that Toka is
[installed|installation]).

To make the most of your scripts, you will probably want to handle
command line arguments. Toka allows for this using the following words:

#pre
  #args        ( -n )   Returns the number of command line arguments
  arglist      ( -a )   An array containing the arguments
  get-element  ( ia-n ) Return a pointer to an element in the array
#unpre

Toka accepts a command line like the following:

#pre
  toka <script> <arg0> <arg1> ... <argN>
#unpre

If no arguments are given to Toka, <i>excluding than the optional script
filename</i>, <b>#args</b> will be set to <i>0</i>. In any other case,
<b>#args</b> will contain the number of arguments <i>following</i> the
script name. For example, in the following example, <b>#args</b> will
return <i>3</i>:

#pre
  toka foo.toka apple banana carrot
#unpre

The breakdown in the <b>arglist</b> will then be as follows:

* Element 0 is the name of the script, in this case <i>foo.toka</i>
* Element 1 is <i>apple</i>
* Element 2 is <i>banana</i>
* Element 3 is <i>carrot</i>

You can iterate over the arguments to process them. For instance, if we
wanted to display each of the script arguments, we could do:

#pre
  #args [ i arglist get-element type cr ] +iterate
#unpre} 1177553596


#--------------------------------------------------
# Search

page Search {[@searchIndex@]} 1175217539


#--------------------------------------------------
# ShellLibrary

page ShellLibrary {This library provides the fundamental support for calling external files
and doing actions normally done at the shell.

The provided API follows:

#pre
  remove
  ( $-n )
  Delete file '$'

  system
  ( $-n )
  Run string '$' as a shell command
#unpre} 1177901415


#--------------------------------------------------
# SocketLibrary

page SocketLibrary {The socket library is a <i>hybrid library</i>. It provides both a C
library module and a set of Toka bindings. The functionality is dependent
on both.

The provided API is as follows:

#pre
  pBind
  ( n-x )
  Bind to a specific port

  pConnect
  ( $n-s )
  Connect to host (string '$') at port 'n'. Returns a socket.

  pAccept
  ( n-x )
  Accept a new connection upon a socket.  Return the new client.

  pRead
  ( sbl-n )
  Attempt to read 'l' chars from socket 's' into buffer 'b'. Returns
  the number of bytes read.

  pWrite
  ( sbl-n )
  Attempt to write 'l' bytes from buffer 'b' to socket 's'. Returns
    the number of bytes written.

  pClose
  ( s-x )
  Attempt to close socket 's'.
#unpre

This API, while minimalistic, is sufficient to allow development of both
client and server applications. It has been used in conjunction with the
[StringsLibrary] and the [ShellLibrary] to implement a working HTTP
server.} 1177901287


#--------------------------------------------------
# Stack Comments

page {Stack Comments} {Stack comments provide a way to specify the action of a quote as it
relates to the stack. It's normally a good idea to keep a list of words
with their description and stack comments on hand if they are not part of
the source.

A typical stack comment will resemble the following:

#pre
  ( abc-d )
#unpre

The dash shows the before/after split. In the example above, the quote
takes three elements from the stack (a, b, and c) and leaves a new one
(d). 

Words that parse use <i>"</i> as a symbol to denote this. For example:

#pre
  ( a"-b )
#unpre

This is a stack comment for a word that takes a string (a), parses the
input until a specified symbol is encountered, and returns a new string
(b).

The exact meaning of the symbols is up to you. Generally in a
description, you can explain them better, but the stack comment form is
just a general overview.

<i>When you are learning Toka, it may be helpful to write out stack
comments for each step in a quote. This can help you keep track of the
stack and become more comfortable using it.</i>} 1177716268


#--------------------------------------------------
# stack.c

page stack.c {= Use =

Implements the basic stack operations. This is intentionally kept
minimal, though additional primitives can be added to improve overall
performance.

= Functions Provided =

#pre
stack_dup()
Duplicate the TOS

stack_drop()
Drop the TOS

stack_swap()
Exchange TOS and NOS

stack_to_r()
Push TOS to return stack, DROP TOS

stack_from_r()
Pop TORS to the data stack

stack_depth()
Return the number of items on the stack
#unpre

= Primitives Provided =

#pre
dup
drop
swap
>r
r>
depth
#unpre} 1176258218


#--------------------------------------------------
# strings

page strings {Strings are sequences of characters. Specifically a string is any
sequence of ASCII characters (each character can have a length identical
to <b>char-size</b>), and ending with the literal value 0.

Strings are created by parsing, or can be manually constructed as an
array. For example the following two are functionally identical:

#pre
  " hello" is-data hello
  hello type cr

  5 chars is-array hello
  char: h 0 hello put-char-element
  char: e 1 hello put-char-element
  char: l 2 hello put-char-element
  char: l 3 hello put-char-element
  char: o 4 hello put-char-element
        0 5 hello put-char-element
  hello type cr
#unpre

Since all strings are arrays, you can also manipulate individual elements
in a string:

#pre
  " hello" is-data hello
  hello type cr

  #! Now change the lowercase 'h' to uppercase.
  char: H 0 hello put-char-element
  hello type cr
#unpre

=== Tips ===

* <b>char-size</b> is normally equal to <i>1</i>, corresponding to one
  byte.
* It is possible (though not likely) to have a <b>char-size</b> larger
  than one byte.
* Use <b>c@</b> and <b>c!</b> when manipulating <b>char-size</b> elements.
* Do not use <b>@</b> and <b>!</b> (which are for <b>cell-size</b> elements).} 1177537581


#--------------------------------------------------
# StringsLibrary

page StringsLibrary {Toka provides a [loose abstraction|types] for strings. The strings
library is an attempt to significantly expand on that abstraction and
allow for many common actions to be done quickly and easily.

#pre
 Provides (from libc):
   strcpy   strncpy   strcat   strncat   strcmp   strncmp
   strchr   strstr    strlen   strrchr   strtok

 Provides:
   Data:    $[cr]     $[lf]
   Words:
            grow-string
            ( an-b )  
            Allocate a new string 'n' chars longer than the original
            'a' and copy the original string to it. Returns a pointer
            to the new string ('b').

            append-string
            ( ab-c )
            Combine strings 'a' and 'b' into a new string 'c'. This
            allocates the necessary space for the new string
            automatically.

            clone-string
            ( a-b )
            Create a new string ('b') identical to string 'a'. Space
            is allocated automatically.

            string-find-token
            ( ac-b )
            Search for character 'c' in string 'a'. Returns a new
            string containing everything up to, but not including
            'c'.

            string-find-substring
            ( ab-c )
            Search for string 'b' in string 'a'. Return a new string
            'c' starting with string 'b' and containing the rest of
            string 'a'.

            string-find-char
            ( ac-b )
            Search string 'a' for character 'c'. Return a new string
            'b' that starts with character 'c'.

            after-"
            ( a"-b )
            A parsing word. Parse ahead until " is encountered, then
            append string 'a' to it. Returns a new string 'b'.

            +lf
            ( a-b )
            Append a linefeed (ascii 13) to a string. Returns a new
            string.

            +cr
            ( a-b )
            Append a carriage return (ascii 10) to a string. Returns
            a new string.
#unpre} 1177901521


#--------------------------------------------------
# threading model

page {threading model} {Toka relies on <i>call threading</i>. This is an implementation technique
in which a list of addresses is compiled. Each of these is then called in
sequence. The model is similar to <i>direct threading</i> in the Forth
world.

There is one special address which marks the end of a threaded sequence.
This address is <b>0</b>.

As an example of this, consider the following quote:

#pre
 [ a b c 1 2 + . ]
#unpre

This is compiled into a list of addresses:

#pre
 a, b, c, lit, 1, lit 2, +, ., 0
#unpre

Note the special form for numbers. The [lit()|vm.c] function pushes the value in
the following cell to the stack.

When this quote is invoked, <i>a</i> will be called. After it finishes
executing, <i>b</i> will be called, and so on until <i>0</i> is
encountered. At that point, the [vm_run()|vm.c] function exits.} 1176257425


#--------------------------------------------------
# TimeLibrary

page TimeLibrary {This library allows obtaining the system time, timing functions, and
similar activities.

#pre
   Data:
     time_t
     
   Words:
     time
     difftime
     ctime
     .time
     :time
#unpre

#---

=== Examples ===

#pre
  needs time
  time_t today
  today time drop
  today ctime type
#unpre

#pre
  needs time
  [ dup 1 > [ dup 1 - recurse swap 2 - recurse + ] [ ] ifTrueFalse ] is fib
  [ 35 fib . cr ] :time
#unpre} 1177901642


#--------------------------------------------------
# toka.c

page toka.c {= Use =

Setup and call the interpreter.

= Functions Provided =

#pre
main()
The main entry point into Toka. Sets up the
dictionary and calls interpret().
#unpre

= Primitives Provided =

<i>None</i>} 1175294848


#--------------------------------------------------
# TokaDoc

page TokaDoc {= Introduction =

To help keep an up-to-date list of C functions and their Toka
equivilents, the TokaDoc scripts were developed. These seach C sources
for specially formatted comments and extract them into various files.
These files can be updated when [building].

= Supporting TokaDoc =

At the start of each C file, have a comment header like this:

#pre
 /*
  *|F|
  *|F| FILE: filename
  *|F|
  */
#unpre

Before any global variables, have a comment block like this:

#pre
/*
 *|F| Variables:
 *|F|   GCITEM gc_list[128]
 *|F|   Holds the list of items marked as garbage.
 *|F|
 */
#unpre

Before each function have a comment block like this:

#pre
 /*
  *|F| <return type> functioname(<arguments>)
  *|F| description of the function
  *|F|
  */
#unpre

And for any functions having a Toka equivilent, have a block like:

#pre
 /*
  *|G| wordname    stack-effect    description
  */
#unpre

Please try to keep columns lined up as much as possible for Toka wordlist comments.} 1175313140


#--------------------------------------------------
# Tutorial

page Tutorial {This is a series of lessons on the Toka programming language. It's based
directly on the tutorials for Forth and Open Firmware that were written
by Mitch Bradley for the OLPC project.

The original lessons can be found at http://wiki.laptop.org/go/Forth_Lessons

I have made as few changes as possible to the lessons I adapted. I truely
hope this proves beneficial to all those who may wish to learn to use
Toka.

#---

=== The Lessons ===

* [Lesson 0] - Motivation and Basic Syntax 
* [Lesson 1] - Stack and Numbers 
* [Lesson 2] - Stack diagrams and Comments 
* [Lesson 3] - Arithmetic Operators and Calculations 
* [Lesson 4] - Making New Definitions 
* [Lesson 5] - Variables and Data Storage 

Now that you have seen the basics, proceed to [First Steps] and explore
the Toka language in more detail.} 1178750135


#--------------------------------------------------
# Types

page Types {Toka has one data type, called the <i>cell</i>. This is a machine
dependent sized memory area that can hold a single number or pointer. On
32-bit systems, cells are 4 bytes in length, and on 64-bit systems, they
take 8 bytes. A constant, <b>cell-size</b>, returns the exact length
provided by Toka on your system.

Cells can hold numbers, pointers to allocated memory, and pointers to
quotes. When Toka encounters a number or a pointer, it is placed on the
stack. For more permanent storage, you can store cell values into memory
locations for later use. 

This is where a number of abstractions arise. Memory allocated for
storage of values is called [variables]. Memory allocated for sequences
of values are called [arrays]. And a special class of array is used for
sequences of characters. These are called [strings].

In all of these, when you reference them, a <i>pointer</i> is left on the
stack. Pointers are simply numbers corresponding to an actual memory
address. <i>It is up to you to know what abstract data type a pointer
represents</i>.

When dealing with variables, you can use <b>@</b> (fetch) and <b>!</b>
(store) to set and obtain the values stored in them. If you need to fetch
or store single characters (as may arise when manipulating strings), you
can use <b>c@</b> and <b>c!</b> instead.

Arrays have an entire abstracted set of words for dealing with them. It's
well worth learning to use these, as they are portable, and make
accessing and setting individual elements in an array trivial.

=== Tips ===

You are strongly encouraged to use <b>cell-size</b> and <b>char-size</b>
instead of hard coding the sizes for data. This helps ensure readability
and portability.} 1177462962


#--------------------------------------------------
# User Code

page {User Code} {Use this page to extend Notebook using the 
[@helpbtn "the Tcl language"@].  Commands you add here can be used as
[@helpbtn "Magic Button"@]s and [@helpbtn "Embedded Macro"@]s.

Note that you can intersperse normal prose in between blocks of Tcl code.

= User Menu =

The [@helpbtn "User Menu"@] pops up when you right-click or control-click 
on a page in the [@helpbtn "Page Browser"@].  You can customize it however you like.

#Tcl
usermenu {
    Back back-page
    Home {goto-page Home}
}
#unTcl

= Edit Menu =

The [@helpbtn "Edit Menu"@] pops up when you right-click or control-click 
on a page in the [@helpbtn "Page Editor"@].  You can customize it however you like.

#Tcl
editmenu {
    Undo             undo-change
    Redo             redo-change
    separator {}
    Cut              cut-string
    Copy             copy-string
    Paste            paste-string
    "Insert Page..." insert-page
}
#unTcl

= Example =

The following [@helpbtn "embedded macro"@] used to be used by the
[Tour] to create a [@helpbtn "magic button"@] that said 
"Click here to continue..." and took you to the next page in the tour
when you clicked it.  It's no longer needed, because now you can write
such links directly, like this:

  [Click here to continue...|Tour 2]

Still, it's a nice example of how to write a macro that creates a button.

#Tcl
proc clickToContinue {name} {
	return "\[%Click here to continue...|goto-page [list $name]%\]"
}
#unTcl} 1113420734


#--------------------------------------------------
# UsingTheStack

page UsingTheStack {he language makes use of a stack to pass data between functions (called
<i>quotes</i> in toka). Imagine a stack of blocks with numbers on them.
You can add or remove numbers from the top of the stack. You can also
rearrange the order of the numbers.

The stack is initially empty. Let's start by putting some numbers on the
stack. Type in:

#pre
  23 7 9182
#unpre

Excellent! Now print the number on top of the stack using <b>.</b>, which
is pronounced "dot". This is a hard word to write about in a manual
because it is just a single period.

Enter:

#pre
  .
#unpre

You should see the last number you entered, 9182, printed. Each time
<b>.</b> is used, the top element on the stack is lost. If you want to
see what is on the stack, you can use <b>:stack</b>. Try this:

#pre
  :stack
#unpre

You should see:

#pre
  <2> 23 7
#unpre

The number on the left, enclosed in brackets, is the number of items on
the stack. The number to the far right is the top of the stack, or
<i>TOS</i>. It should be mentioned that <b>:stack</b> leaves the stack
unchanged.

Since Toka uses the stack to hold data being operated on, and it uses the
stack to pass data between quotes, it is very important to practice using
it. Quotes generally take what they need off of the stack, and put their
results back on it. To help understand exactly what each quote consumes
and leaves, we use <i>stack diagrams</i>. As an example:


#pre
  . ( x- )
#unpre

That is to say, <b>.</b> takes one word off the stack (the 'x') and puts
nothing on the stack. In other words, it consumes the TOS.

In the examples that follow, you do not need to type in the comments.
When you are programming, of course, liberal use of comments and stack
diagrams may make your code more readable and maintainable.

Between examples, you may wish to clear the stack. If you enter
<b>reset</b>, the stack will be cleared. Since the stack is central to
Toka, it is important to be able to alter it easily. Let's look at some
more functions that manipulate the stack. Enter:

#pre
  reset
  777 dup :stack
#unpre

You will notice that there are two copies of 777 on the stack. The quote
<b>dup</b> duplicates TOS. This is useful when you want to use the TOS
and still have a copy. The stack diagram for <b>dup</b> would be:

#pre
  dup ( x-xx )
#unpre

Another useful quote is <b>swap</b>. Enter:

#pre
  reset
  23 7 :stack
  swap :stack
#unpre

The stack should look like:

#pre
  <2> 7 23
#unpre

The stack diagram for <b>swap</b> would be:

#pre
  swap ( xy-yx )
#unpre

Now enter:

#pre
  over :stack
#unpre

You should see:

#pre
  <3> 7 23 7
#unpre

<b>over</b> causes a copy of the second item on the stack to leapfrog
over the first. Its stack diagram would be:

#pre
  over ( xy-xyx )
#unpre

Here is another commonly used function:

#pre
  drop ( x- )
#unpre

Can you guess what we will see if we enter:

#pre
  drop :stack
#unpre

Another handy function for manipulating the stack is <b>rot</b> (short
for rotate). Enter:

#pre
  11 22 33 44 :stack
  rot :stack
#unpre

The stack diagram for <b>rot</b> is, therefore:

#pre
  rot ( xyz-yzx )
#unpre

You have now learned the more important stack manipulation words. These
will be present in almost every non-trivial Toka program. I will say that
if you see heavy use of these words in your code, you may want to examine
and reorganize (<i>refactor</i>) your code. Use of variables and arrays
(which we will discuss later) can also help clean things up.

Here are stack diagrams for some other useful stack manipulation
functions. Try experimenting with them by putting numbers on the stack
and calling them to get a feel for what they do. Again, the text in
parentheses is just a comment and need not be entered.

#pre
  2drop ( xyz--x )
  2dup ( xy-xyxy )
  nip ( xyz-xz )
  tuck ( xy-yxy )
#unpre} 1177452284


#--------------------------------------------------
# Variables

page Variables {To hold data for longer periods of time than is practical with the stack,
variables can be used. Variables are pointers to memory locations large
enough to hold a number. There are two primary ways to create variables:

#pre
  variable foo
  variable bar
  variable baz
#unpre

The above would create three new variables, named <b>foo</b>, <b>bar</b>,
and <b>baz</b>. When creating multiple variables, it is more readable to
use <b>variable|</b> though:

#pre
  variable| foo bar baz |
#unpre

You can use <b>@</b> (fetch) and <b>!</b> (store) to alter the contents
of a variable:

#pre
  variable foo
  100 foo !
  foo @ .
#unpre

For reading/writing character-sized values, <b>c@</b> and <b>c!</b> are
also provided. A full list of functions for working with variables follows:

#pre
  variable ( "- )      Parse ahead and create a named entry
                       corresponding to a memory location
  variable| ( |- )     Parse and create variables until | 
                       is encountered.
  @        ( a-n )     Fetch the value from variable 'a'
  !        ( na- )     Store 'n' to variable 'a'
  c@       ( a-n )     Fetch a byte from variable 'a'
  c!       ( na- )     Store byte 'n' to variable 'a'
#unpre} 1177020319


#--------------------------------------------------
# vm.c

page vm.c {= Use =

Implements the heart of the virtual machine.

= Functions Provided =

#pre
Variables:
  Inst *heap
  Pointer into the current heap

  Inst *ip
  The instruction pointer

  long stack[100], rstack[100]
  The data and return stacks

  long sp, rsp
  The stack pointers

vm_run(Inst)
Run through a list of instructions
Side effects:
  modifes *ip

vm_stack_check()
Check for over/underflow and reset if detected
If the return stack over/underflows, exit Toka

push(long a)
Push a number to the stack.

lit()
Push the value in the following memory location
to the stack
#unpre

= Primitives Provided =

#pre
heap
#unpre} 1175294932


#--------------------------------------------------
# WordClasses

page WordClasses {An implementation strategy adopted from HelFORTH. Each quote, primitive,
and data structure has a <i>class</i> assigned to it. These classes are
aware of the current compiler state (<i>on</i> or <i>off</i>), and may be
aware of other aspects of the Toka system as well.

When an item is found, the corresponding <i>class handler</i> is invoked.
The primary classes you will encounter in Toka are:


== is ==

This is the most common class. 

* Compiling: compile a call to the quote.
* Interpreting: invoke the quote.

== is-macro ==

A special case, these are used for quotes that need to be invoked
whenever they are encountered. Macro class is used for creating strings
(via <b>"</b>) and symbolic creation of characters (via <b>char:</b>).

* Compiling: invoke the quote.
* Interpreting: invoke the quote.

== is-data ==

This is the second most common class. It is used for all data structures,
including variables, arrays, and strings.

* Compiling: compile the value into the quote.
* Interpreting: leave the value on the stack.} 1177736583


#--------------------------------------------------
# Words and Their Uses

page {Words and Their Uses} {= Primitives =

These are words that are built into the Toka executable. If the
<b>bootstrap.toka</b> can not be found, these are the only words 
that will be provided.

#pre
<<       ( ab-c )    Shift 'b' left by 'a' bits
>>       ( ab-c )    Shift 'b' right by 'a' bits
and      ( ab-c )    Perform a bitwise AND
or       ( ab-c )    Perform a bitwise OR
xor      ( ab-c )    Perform a bitwise XOR
#args    (  -n )     Return the number of arguments
arglist  (  -a )     Return a pointer to the 
                     argument list.
<        ( ab-f )    Compare 'a' and 'b', return
                     a flag
>        ( ab-f )    Compare 'a' and 'b', return
                     a flag
=        ( ab-f )    Compare 'a' and 'b', return
                     a flag
<>       ( ab-f )    Compare 'a' and 'b', return
                     a flag
.        ( n- )      Display the TOS
emit     ( c- )      Display the ASCII character
                     for TOS
type     ( a- )      Display a string
bye      ( - )       Quit Toka
#        ( n- )      Push the following cell to
                     the stack.
@        ( a-n )     Fetch the value in memory
                     location 'a'
!        ( na- )     Store 'n' to memory location
                     'a'
c@       ( a-n )     Fetch a byte from memory
                     location 'a'
c!       ( na- )     Store byte 'n' to memory
                     location 'a'
copy     ( sdc- )    Copy 'c' bytes from 's' to
                     'd'
cell-size ( -n )     Return the size of a cell
char-size ( -n )     Return the size of a char
:words   ( - )       Display a list of all named
                     quotes and data
:stack   ( - )       Display all values on the
                     data stack
:gc      (  -  )     Display information about
                     the garbage collection list
:see     (  "- )     Decompile the specified quote
is       ( a"- )     Attach a name to a quote
         ( a$- )     Non-parsing form
is-macro ( a"- )     Attach a name to a quote
         ( a$- )     Non-parsing form
is-data  ( a"- )     Attach a name to data memory
         ( a$- )     Non-parsing form
`        ( "-a )     Return a quote corresponding
                     to the specified word.
         ( $-a )     Non-parsing form
from     ( "- )      Set the library to import from
         ( $- )      Non-parsing form
import   ( n"- )     Import a function taking 'n'
                     arguments.
         ( n$- )     Non-parsing form
as       ( "- )      Rename the last defined word
         ( $-  )     Non-parsing form
file.open  ( $m-n )  Open a specified file with
                     the specified mode.
file.close ( n- )    Close the specified file handle
file.read  ( nbl-r ) Read 'l' bytes into buffer 'b'
                     from file handle 'n'. Returns
                     the number of bytes read.
file.write ( nbl-w ) Write 'l' bytes from buffer 'b'
                     to file handle 'n'. Returns
                     the number of bytes written.
file.size  ( n-s )   Return the size (in bytes)
                     of the specified file.
file.seek  ( nom-a ) Seek a new position in the
                     file. Valid modes are
                     START, CURRENT, and END. These
                     have values of 1, 2, and 3.
file.pos   ( n-a )   Return a pointer to the current
                     offset into the file.
keep     ( a-a )     Mark quotes/allocated memory
                     as permanent.
gc       ( - )       Clean the garbage
malloc   ( n-a )     Allocate 'n' bytes of memory
heap     ( -a )      Variable pointing to the top
                     of the local heap
compiler ( -a )      Variable holding the compiler
                     state
count    ( a-ac )    Return an address/count pair
                     for a string
+        ( ab-c )    Add TOS and NOS
-        ( ab-c )    Subtract TOS from NOS
*        ( ab-c )    Multiply TOS by NOS
/mod     ( ab-cd )   Divide and get remainder
base     ( -a )      Variable containg the current
                     numeric base
parser   ( -a )      Variable holding current parser
                     mode.
escape-sequences ( -a)  Variable determining if
                        escape sequences are used.
>number  ( a-nf )    Attempt to convert a string
                     to a number
parse    ( d-a )     Parse until the character 
                     represented by 'd' is found.
                     Return a pointer to the string
include  ( "- )      Attempt to open a file and
                     add it to the input stack.
         ( $- )      Non-parsing form
needs    ( "- )      Attempt to include a file
                     from the library (normally
                     /usr/share/toka/library)
         ( $- )      Non-parsing form
end.     ( - )       Remove the current file from
                     the input stack
[        ( -a )      Create a new quote
]        ( - )       Close an open quote
invoke   ( a- )      Execute a quote
compile  ( a- )      Compile the code needed to call 'a'
iterate  ( na- )     Execute a quote 'n' times
+iterate ( na- )     Execute a quote 'n' times
ifTrueFalse ( fab- ) Invoke 'a' if 'f' flag is
                     true, 'b' if false.
recurse  ( - )       Compile a call to the top
                     quote.
i        ( -n )      Return the current loop index
whileTrue  ( a- )    Execute quote. If the quote
                     returns TRUE, execute again.
                     otherwise end the cycle.
whileFalse ( a- )    Execute quote. If the quote
                     returns FALSE, execute again.
                     otherwise end the cycle.
dup      ( n-nn )    Duplicate the TOS
drop     ( n- )      Drop the TOS
swap     ( ab-ba )   Exchange the TOS and NOS
>r       ( n- )      Push TOS to return stack, DROP
r>       ( -n )      Pop TORS to the data stack
depth    ( -n )      Return the number of items
                     on the stack
#unpre

= Bootstrap =

These are additional words, provided in <b>bootstrap.toka</b>.
They significantly expand the core language.

#pre
#!       ( "- )      Parse to the end of the line
                     and scrap the results.
(        ( "- )      Parse until ) is found and scrap
                     the results
SPACE    ( -n )      ASCII value for SPACE character
CR       ( -n )      ASCII value for CR character
LF       ( -n )      ASCII value for LF character
ESC      ( -n )      ASCII value for ESC character
TAB      ( -n )      ASCII value for TAB character
wsparse  ( -a )      Parse until a SPACE is encountered
lnparse  ( -a )      Parse to the end of the line,
                     leave the resulting string on the
                     stack.
FALSE    ( -f )      Value returned for FALSE
TRUE     ( -f )      Value returned for TRUE
ifTrue   ( fq- )     Execute quote ('q') if flag ('f') is TRUE
ifFalse  ( fq- )     Execute quote ('q') if flag ('f') is FALSE
>char    ( n-c )     Convert the value on TOS to a single character
char:    ( "-c )     Parse ahead and return one character
"        ( "-$ )     Parse until " is encountered and return a string
cr       ( - )       Display a CR character
space    ( - )       Display a space
tab      ( - )       Display a tab
."       ( "- )      Parse to the next ", display the string.
clear    ( - )       Clear the screen
normal   ( - )       Set the colors back to the default
bold     ( - )       Set the bold attribute for the foreground color
black    ( - )       Set the foreground color to black
red      ( - )       Set the foreground color to red
green    ( - )       Set the foreground color to green
yellow   ( - )       Set the foreground color to yellow
blue     ( - )       Set the foreground color to blue
magenta  ( - )       Set the foreground color to magenta
cyan     ( - )       Set the foreground color to cyan
white    ( - )       Set the foreground color to white
onBlack  ( - )       Set the background color to black
onRed    ( - )       Set the background color to red
onGreen  ( - )       Set the background color to green
onYellow ( - )       Set the background color to yellow
onBlue   ( - )       Set the background color to blue
onMagenta( - )       Set the background color to magenta
onCyan   ( - )       Set the background color to cyan
onWhite  ( - )       Set the background color to white
nip      ( xy-y )    Remove the second item on the stack
rot      ( abc-bca ) Rotate top three values on stack
-rot     ( abc-acb ) Rotate top three values on stack twice
over     ( xy-xyx )  Put a copy of NOS above the TOS
tuck     ( xy-yxy )  Put a copy of TOS under NOS     
2dup     ( xy-xyxy ) Duplicate the top two items on the stack
2drop    ( xy- )     Drop TOS and NOS
reset    ( *- )      Drop all items on the stack
r@       ( -x )      Get a copy of the top item on the return stack
1+       ( x-y )     Increase value on stack by 1
1-       ( x-y )     Decrease value on stack by 1
negate   ( x-y )     Invert the sign of TOS
/        ( xy-z )    Divide two numbers
mod      ( xy-z )    Divide two numbers and get remainder
not      ( x-y )     Invert the value 'x'
*/       ( abc-d )   (a*b)/c
chars    ( x-y )     Multiply TOS by char-size. Useful w/arrays
char+    ( x-y )     Increase TOS by char-size
char-    ( x-y )     Decrease TOS by char-size
cells    ( x-y )     Multiply TOS by cell-size. Useful w/arrays
cell+    ( x-y )     Increase TOS by cell-size
cell-    ( x-y )     Decrease TOS by cell-size
+!       ( xa- )     Add 'x' to the value in address 'a'
-!       ( xa- )     Subtract 'x' from the value in address 'a'
on       ( a- )      Set a variable to TRUE
off      ( a- )      Set a variable to FALSE
toggle   ( a- )      Toggle a variable between TRUE and FALSE
variable ( "- )      Create a variable
variable| ( "- )     Create multiple variables
hex      ( - )       Set the base to hexadecimal (16)
decimal  ( - )       Set the base to decimal (10)
binary   ( - )       Set the base to binary (2)
octal    ( - )       Set the base to octal (8)
"R"      ( -x )      Mode for file.open
"R+"     ( -x )      Mode for file.open
"W"      ( -x )      Mode for file.open
"W+"     ( -x )      Mode for file.open
"A"      ( -x )      Mode for file.open
"A+"     ( -x )      Mode for file.open
START    ( -x )      Mode for file.seek
CURRENT  ( -x )      Mode for file.seek
END      ( -x )      Mode for file.seek
file.slurp        ( $-a )   Read a file into a dynamically allocated buffer 
is-array          ( n"- )   Create an array of size 'n'
get-element       ( ia-n )  Get element 'i' from array 'a'
put-element       ( nia- )  Put value 'n' into element 'i' of array 'a'
get-char-element  ( ia-n )  Get char-size element 'i' from 
                            array 'a'
put-char-element  ( nia- )  Put char-size value 'n' into element 'i' of 
                            array 'a'
<list>   ( -a )      Stores a list of pointers used by { and }
{        ( - )       Start a scoped area
}        ( - )       End a scoped area
#unpre
} 1178882049


# End of Notebook Database File
