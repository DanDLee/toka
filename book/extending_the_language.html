<html><head><title>toka.nbk: Extending the Language</title>
</head>
<body>


<p><b>toka.nbk:</b> <a href="home.html">Home</a> | <a href="index.html">Index</a> | Next Page: <a href="ffi.html">FFI</a> | Previous Page: <a href="errorsc.html">errors.c</a></p>

<hr>

<h1>&nbsp;Extending the Language</h1>


<p>Toka provides a few tools that allow you to extend the language in new
directions. The core of this is <i>compiler macros</i>, special words
which are (under normal circumstances) always invoked.
</p>
<p>Consider a fairly simple task, such as displaying a string. We know that
this can be done by using <b>type</b>, and that <b>parse</b> can be used to
create a string. A simple first try would be something like:
</p>
<pre>  [ char: " parse type ] is ."
</pre>

<p>Trying this at the interpreter works just fine:
</p>
<pre>  ." Hello, World"
</pre>

<p>But inside a definition, we run into a problem:
</p>
<pre>  [ ." Hello, World" ] is foo
  E0: 'Hello,' is not a word or a number.
  E0: 'World"' is not a word or a number.
</pre>

<p>To make this work inside a definition, we need to do a few things:
</p>

<ul>
<li> Parse the string at compile time
<li> Compile in a reference to the string
<li> Compile a call to <b>type</b> into the quote

</ul>

<p>To begin, we should be using <b>is-macro</b> to make this into a compiler
macro. As a macro, it will also run in the interpreter, so we need to
make it aware of the <b>compiler</b> state. This is provided by the
<b>compiler</b> variable. So an initial expansion:
</p>
<pre>  [ char: " parse 
    compiler @ [ ( for compile time ) ] [ type ] ifTrueFalse 
  ] is-macro ."
</pre>

<p>A simplification is now in order. The first two challenges (parsing the
string and compiling a reference to it) are already handled by the
<b>"</b> word. We can reuse this and save some trouble:
</p>
<pre>  [ ` " invoke
    compiler @ [ ( for compile time ) ] [ type ] ifTrueFalse 
  ] is-macro ."
</pre>

<p><b>`</b> returns a quote containing the requested function, in this case
<b>"</b>. We can then <b>invoke</b> the quote. This is a fundamental
aspect of extending the langauge. 
</p>
<p>To compile a call to a quote, Toka provides another word, <b>compile</b>.
We can use this as follows:
</p>
<pre>  [ ` " invoke
    compiler @ [ ` type compile ] [ type ] ifTrueFalse 
  ] is-macro ."
</pre>

<p>And now we are done. Use of <b>`</b>, <b>invoke</b>, and <b>compile</b>
allows for a fair amount of flexibility in extending the language with
new features. Learn to use them, and your ability to adapt Toka to your
programs needs will multiply drastically.
</p>
<p>These functions can also be used with normal quotes to create defining
words. As a nominal example, this is a defining word that creates a
function that always returns a specific value. Basically a form of
constant:
</p>
<pre>  [ &gt;r ` [ invoke r&gt; # ` ] invoke is ] is const
</pre>


<hr>

<p><b>toka.nbk:</b> <a href="home.html">Home</a> | <a href="index.html">Index</a> | Next Page: <a href="ffi.html">FFI</a> | Previous Page: <a href="errorsc.html">errors.c</a></p>

<hr>

<p><i>Notebook exported on Saturday, 26 May 2007, 17:20:12 PM EDT</i></p>

</body></html>
